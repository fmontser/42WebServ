GET / HTTP/1.1
Host: localhost


HTTP/1.1 200 OK\r\n
Date: 17/01/2025\r\n
\r\n
<!DOCTYPE html>\n
<html lang="es">\n
\n
<head>\n
\t<meta charset="UTF-8">\n
\t<link rel="icon" href="favicon.ico">\n
\t<meta name="viewport" content="width=device-width, initial-scale=1.0">\n
\t<title>TEST</title>\n
\n
\t<link rel="stylesheet" href="index.css" />\n
</head>\n
\n
<body>\n
\t<h1>HELLO WORLD >> INDEX</h1>\n
</body>
\n
\n


for (std::list<pollfd>::iterator it = _pollSockets.begin(); it != _pollSockets.end() ; ++it) {
		std::vector<pollfd> tempVector (_pollSockets.begin(), _pollSockets.end());
		pollValue = poll(tempVector.data(), tempVector.size(), TIMEOUT);
		if (pollValue == -1) {
		//TODO gestionar error de socket
		std::cerr << RED << "Error: WebSocket error" << END << std::endl;
	}
	else if (pollValue > 0) {
		if ((*it).fd == _config.getWebSocket().getSocketFd()) {
			pollfd	newSocket;
			newSocket.fd = acceptConnection();
			newSocket.events = POLLIN | POLLOUT | POLLERR | POLLHUP;
			newSocket.revents = 0;
			_pollSockets.push_back(newSocket);
			recieveData(newSocket.fd);
		}
		else if ((*it).revents & POLLIN) {
			recieveData((*it).fd);
		}
		else if ((*it).revents & POLLOUT) {
			//TODO es posible escribir
		}
		else if ((*it).revents & POLLHUP) {
			close((*it).fd);
			_pollSockets.erase(it);
		}
		else if ((*it).revents & POLLERR) {
			//TODO error
		}
}
}