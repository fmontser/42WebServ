<!DOCTYPE html>
<html lang="es">

<head>
	<meta charset="UTF-8">
	<link rel="icon" href="favicon.ico">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Guia 42WebServ</title>

	<link rel="stylesheet" href="index.css" />
<!--
	<style>
		body {
			font-family: Arial, sans-serif;
			background-color: #cecccc;
			padding-left: 2em;
		}

		h1 {
			color: #333;
		}

		p {
			font-size: 16px;
			line-height: 1.5;
		}

		section {
			padding-left: 1em;
			display: none;
		}

		#toogleReq:checked + #sectionReq {
			display: block;
		}

		#toogleConfigFile:checked + #sectionConfigFile {
			display: block;
		}

		#toogleLimits:checked + #sectionLimits {
			display: block;
		}

		#toogleFuncs:checked + #sectionFuncs {
			display: block;
		}

		#toogleProcs:checked + #sectionProcs {
			display: block;
		}

		#toogleFileSys:checked + #sectionFileSys {
			display: block;
		}

		#toogleSockets:checked + #sectionSockets {
			display: block;
		}

		#toogleAddress:checked + #sectionAddress {
			display: block;
		}

		#toogleEvents:checked + #sectionEvents {
			display: block;
		}

		#toogleErrors:checked + #sectionErrors {
			display: block;
		}


		#toogleConcepts:checked + #sectionConcepts {
			display: block;
		}

		#toogleHTTP:checked + #sectionHTTP {
			display: block;
		}

		#toogleCGI:checked + #sectionCGI {
			display: block;
		}

		#toogleConceptSockets:checked + #sectionConceptSockets {
			display: block;
		}
	
		label {
			cursor: pointer;
			color: rgb(61, 55, 215);
			font-weight: bold;
			text-decoration: underline;
			padding-left: 1em;
		}

		.functionList {
			text-wrap-mode: wrap;
			background-color: #a9a9a9;
			border-radius: 5px;
			font-family: 'Courier New', monospace;
			font-size: 12px;
		}

		blockquote {
			background-color: #ceadad;
			border-radius: 5px;
			font-family: 'Courier New', monospace;
			font-style: italic;
			font-size: 14px;
			overflow-x: auto;
			margin-right: 2em;
			padding: 1em;
		}
		
		.infoquote {
			background-color: #b4c3d3;
			border-radius: 5px;
			font-family: 'Courier New', monospace;
			font-style: italic;
			font-size: 14px;
			overflow-x: auto;
			margin-right: 2em;
			padding: 1em;

		}
		.quote {
			background-color: #a9a9a9;
			border-radius: 5px;
			font-family: 'Courier New', monospace;
			font-style: italic;
			font-size: 14px;
			overflow-x: auto;
			margin-right: 2em;
			padding: 1em;
		}

		/* SINTAXIS DE CODIGO */

		pre {
			background-color: #a9a9a9;
			border-radius: 5px;
			font-family: 'Courier New', monospace;
			font-size: 14px;
			overflow-x: auto;
			margin-right: 2em;
		}

		code {
			color: black;
		}


		.keyword {
			color: #e8e539;
			font-weight: bold;
		}

		.functions {
			color: #3f4f7b;
			font-weight: bold;
		}

		.names {
			color: #68481f;
			font-weight: bold;
		}

		.data {
			color: #317912;
		}

		.types {
			color: #0013bc;
			font-weight: bold;
		}

		.comment {
			color: #ffffff;
		}

	</style>
	--->
</head>

<body>
	<h1>GUIA 42 WEBSERV:</h1>
	<p style="font-style: italic;">subject version: 21.2</p>
	<hr>

	<!-- SECCION LIMITACIONES-->

	<label for="toogleLimits">LIMITACIONES</label>
	<input type="checkbox" id="toogleLimits" style="display: none;" >
	<section id="sectionLimits">
		<h3>Restricciones técnicas</h3>
	<ul>
		<li>Prohibido usar <code>fork()</code> excepto para la ejecución de CGIs. </li>
		<li>No se puede usar <code>execve()</code> para invocar otro servidor web. </li>
		<li>Está prohibido realizar operaciones de lectura/escritura sin pasar por <code>poll()</code> (o equivalentes). </li>
		<li>Las librerias externas y Boost estan prohibidas.</li>
		<li>El codigo debe compilar con las flags <strong>-Wall -Wextra -Werror -std=c++98</strong>.</li>
		<li>Makefile debe gestionar la compilacion, almenos con las reglas <strong>$(NAME), all, clean, fclean y re</strong>.</li>

	</ul>
	<h3>Errores críticos</h3>
	<ul>
		<li>El programa no debe cerrarse inesperadamente ni fallar en ninguna circunstancia (incluso en caso de falta de memoria).</li>
	</ul>
		<label for="toogleLimits">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION REQUERIMIENTOS-->

	<label for="toogleReq">REQUERIMIENTOS</label>
	<input type="checkbox" id="toogleReq" style="display: none;" >
	<section id="sectionReq">
		<ol>
			<li>
				<p class="quote"><strong>"Your program has to take a configuration file as argument, or use a default path."</strong></p>
				<p>
					Tu programa debe ser capaz de recibir un archivo de configuración como argumento al ejecutarse, proporcionando flexibilidad en su configuración. Si no se proporciona un archivo de configuración al ejecutar el programa, este debe ser capaz de usar una ruta predeterminada a un archivo de configuración por defecto. Esta configuración flexible es importante para poder adaptar el comportamiento del servidor a diferentes entornos y requisitos sin tener que recompilar el código.  Por ejemplo, si el usuario no especifica un archivo, el servidor podría buscar un archivo llamado `config.conf` en el directorio de trabajo.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"You can’t execve another web server."</strong></p>
				<p>
					Está prohibido usar la función <code>execve</code> para ejecutar otro servidor web como parte de la solución. El objetivo principal de este requerimiento es garantizar que la implementación del servidor web sea completamente de tu autoría y que no dependa de la funcionalidad de otro servidor ya existente. Al evitar el uso de `execve` o funciones similares, se asegura que entiendes y aplicas todos los conceptos necesarios para construir un servidor web funcional. Esto fomenta una comprensión profunda de la implementación de un servidor web.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Your server must never block and the client can be bounced properly if necessary."</strong></p>
				<p>
					Tu servidor debe ser no bloqueante en todas sus operaciones, evitando que se detenga o se congele mientras espera a que se complete una operación (como una lectura o escritura de socket). Además, debe ser capaz de desconectar un cliente de forma apropiada y controlada si es necesario, por ejemplo, cuando un cliente envía datos incorrectos, si hay un timeout o en otras situaciones excepcionales. Esta capacidad de manejar conexiones de forma no bloqueante y rechazar clientes de forma controlada es esencial para la estabilidad y rendimiento del servidor.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"It must be non-blocking and use only 1 poll() (or equivalent) for all the I/O operations between the client and the server (listen included)."</strong></p>
				<p>
					Tu servidor debe ser diseñado utilizando un modelo no bloqueante. Es decir, el servidor debe utilizar una única llamada a la función `poll()` (o una función similar que proporcione las mismas capacidades) para manejar todas las operaciones de entrada/salida con los clientes, incluyendo la escucha de nuevas conexiones (`listen`). Esto significa que todas las operaciones de read, write, y accept deben pasar por una única llamada a `poll()`. El objetivo de este requerimiento es que el servidor sea eficiente en el manejo de múltiples conexiones, al poder verificar la disponibilidad de múltiples sockets con una sola llamada al sistema.  Este modelo  optimiza el uso de los recursos del sistema.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"poll() (or equivalent) must check read and write at the same time."</strong></p>
				<p>
					La función `poll()` (o la función equivalente que uses) debe ser configurada para verificar la disponibilidad de lectura y escritura de los sockets al mismo tiempo, en la misma llamada. El servidor debe estar atento a ambos tipos de eventos (lectura de datos del cliente y escritura de datos hacia el cliente).  Esto permite que el servidor maneje la comunicación en ambas direcciones de forma eficiente, ya que puede estar listo para recibir datos de un cliente y enviar una respuesta simultáneamente.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"You must never do a read or a write operation without going through poll() (or equivalent)."</strong></p>
				<p>
					Nunca debes realizar una operación de lectura (como `read` o `recv`) o de escritura (como `write` o `send`) directamente sobre un descriptor de archivo. Todas las operaciones de entrada/salida (I/O) deben ser precedidas por la verificación de que el socket está listo para la operación utilizando la función `poll()` (o equivalente). Esto asegura que el servidor no se bloquee mientras espera a que una operación de lectura o escritura se complete, manteniendo el modelo no bloqueante. Cualquier acceso directo, que ignore el uso de `poll()`, se considerará una violación de este requerimiento.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Checking the value of errno is strictly forbidden after a read or a write operation."</strong></p>
				<p>
					Está estrictamente prohibido verificar el valor de la variable `errno` después de realizar una operación de lectura o escritura directamente sobre un descriptor de archivo. La variable `errno` contiene un código de error que indica qué salió mal en una operación. Sin embargo, como debes usar `poll()` para saber si un socket está listo para leer o escribir, este debe ser el único mecanismo de detección de errores. Si no respetas esto e intentas usar `errno`, violarás el requerimiento de uso estricto de `poll()`.  Este requerimiento es fundamental para asegurar que se respete el modelo no bloqueante y que el código esté escrito de forma consistente con las directrices establecidas.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"You don’t need to use poll() (or equivalent) before reading your configuration file."</strong></p>
				<p>
					No es necesario utilizar `poll()` (o una función equivalente) antes de leer el archivo de configuración al inicio de tu servidor. La lectura del archivo de configuración se puede realizar utilizando funciones de lectura bloqueantes estándar, como `fopen` y `fread`. Esto es porque se asume que esta es una operación única que se realiza durante la inicialización del servidor y no necesita el manejo de múltiples eventos, por lo que se permite usar funciones bloqueantes sin afectar al resto de la operación del servidor.
				</p>
				<blockquote>
					"Because you have to use non-blocking file descriptors, it is possible to use read/recv or write/send functions with no poll() (or equivalent), and your server wouldn’t be blocking. But it would consume more system resources. Thus, if you try to read/recv or write/send in any file descriptor without using poll() (or equivalent), your grade will be 0."
				</blockquote>
				<p>
					Si bien es técnicamente posible usar funciones de lectura y escritura no bloqueantes como `read`, `recv`, `write`, o `send` en descriptores de archivo no bloqueantes sin la necesidad de `poll()` y, en teoria, no bloquear el hilo principal del programa, esto llevaría a una utilización ineficiente de los recursos del sistema.  Si se realiza esto, el servidor estaría ejecutando operaciones en bucle que consumirian recursos del sistema sin necesidad. Por lo tanto, cualquier intento de usar `read`, `recv`, `write` o `send` directamente en un descriptor de archivo sin pasar primero por `poll()` resultará en una calificación de 0. Este requerimiento se pone para que la implementación de tu servidor sea eficiente.
				</p>

			</li>

			<li>
				<p class="quote"><strong>"You can use every macro and define like FD_SET, FD_CLR, FD_ISSET, FD_ZERO (understanding what and how they do it is very useful)."</strong></p>
				<p>
					Puedes utilizar las macros y definiciones como `FD_SET`, `FD_CLR`, `FD_ISSET` y `FD_ZERO`, las cuales son utilizadas para manipular conjuntos de descriptores de archivo (file descriptor sets). Estas macros forman parte de la API de sockets de Unix y facilitan el manejo de múltiples descriptores de archivo en la función `select()` (o, en este caso, una función equivalente de `poll()`). Si bien este proyecto pide el uso de `poll()`, la comprensión de como funcionan estas macros es útil para el entendimiento general de la manipulación de los descriptores de archivo. En resumen, si bien la funcion usada será `poll()`, el concepto general de manejar un conjunto de descriptores de archivo es el mismo.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"A request to your server should never hang forever."</strong></p>
				<p>
					Todas las peticiones realizadas a tu servidor deben ser respondidas en un tiempo razonable y nunca deben quedarse colgadas esperando una respuesta indefinidamente. Es decir, el servidor no debe quedarse bloqueado esperando a que un cliente envíe información o procese una petición. En el caso de que una petición se tarde demasiado en completar, el servidor debe tener un mecanismo de timeout para rechazar la petición y liberar los recursos, evitando el bloqueo del servidor. Este es un requerimiento vital para garantizar que el servidor sea estable y responda a las peticiones en tiempo y forma.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Your server must be compatible with the web browser of your choice."</strong></p>
				<p>
					Tu servidor debe ser capaz de comunicarse correctamente con cualquier navegador web moderno (por ejemplo, Chrome, Firefox, Safari, etc.). Esto implica que el servidor debe implementar el protocolo HTTP correctamente, incluyendo la gestión de encabezados HTTP, códigos de estado y la codificación de datos. Asegúrate de probar tu servidor con un navegador real para asegurar que las solicitudes y respuestas se manejan de forma correcta y tu servidor es capaz de generar respuestas HTML validas.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"We will consider that NGINX is HTTP 1.1 compliant and may be used to compare headers and answer behaviors."</strong></p>
				<p>
					Se considerará que NGINX, un servidor web de referencia, cumple completamente con el protocolo HTTP 1.1. Esto significa que puedes usar NGINX como una herramienta de referencia para validar el comportamiento de tu servidor. Puedes realizar pruebas comparando los encabezados y las respuestas que genera tu servidor con las que genera NGINX para el mismo tipo de peticiones.  Si tu servidor responde de la misma forma que NGINX, entonces puedes asegurar que implementas correctamente el protocolo HTTP 1.1.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Your HTTP response status codes must be accurate."</strong></p>
				<p>
				   Los códigos de estado HTTP que tu servidor genera en las respuestas deben ser precisos y representar correctamente el resultado de la solicitud del cliente. Por ejemplo, cuando un recurso se encuentra debe devolver un código 200, si el recurso no existe, 404 y si hay un error interno, 500. Usar los códigos correctos es fundamental para el protocolo HTTP y  para el funcionamiento correcto de los clientes que solicitan recursos a tu servidor.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"You server must have default error pages if none are provided."</strong></p>
				<p>
					Tu servidor debe incluir páginas de error por defecto para los casos en los que no se haya especificado páginas de error personalizadas. En caso de que se produzca un error y no exista una página de error configurada, el servidor debe enviar una respuesta HTML genérica para indicar el error al cliente. Esto asegura una experiencia de usuario aceptable incluso cuando se producen errores en el servidor, y evita que el cliente reciba una respuesta HTTP sin información adicional sobre el error.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"You can’t use fork for something else than CGI (like PHP, or Python, and so forth)."</strong></p>
				<p>
					Está prohibido usar la función <code>fork</code> para crear procesos secundarios, excepto en el caso de la ejecución de programas CGI. La función <code>fork</code> es la encargada de crear procesos secundarios en entornos Unix. En este proyecto, la idea es que no uses la funcion `fork` para implementar funcionalidades de paralelismo en tu servidor, esta debe ser usada solo para la invocación de CGIs. La única funcionalidad permitida para usar procesos secundarios es el caso de la ejecución de scripts dinámicos mediante CGIs, como PHP o Python.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"You must be able to serve a fully static website."</strong></p>
				<p>
					Tu servidor debe ser capaz de servir un sitio web que sea totalmente estático, lo que implica que debe poder entregar archivos HTML, CSS, JavaScript, imágenes, vídeos, y cualquier otro tipo de archivo que forme parte de un sitio web estático. Esto es fundamental para que tu servidor pueda servir contenido web básico.  La entrega de archivos estáticos es una funcionalidad básica que todo servidor web debe implementar.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Clients must be able to upload files."</strong></p>
				<p>
					Tu servidor debe permitir que los clientes suban archivos al servidor. Esto implica que el servidor debe manejar las peticiones HTTP de tipo `POST` que incluyan datos de formulario y archivos adjuntos. Además, debes guardar los archivos subidos en el directorio especificado en la configuración. Esta funcionalidad es importante para poder recibir datos y archivos de clientes externos.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"You need at least GET, POST, and DELETE methods."</strong></p>
				<p>
					Tu servidor debe implementar al menos los métodos HTTP `GET`, `POST` y `DELETE`.  El método `GET` se utiliza para obtener recursos del servidor, `POST` para enviar datos al servidor, y `DELETE` para eliminar recursos. Estos métodos son los mas utilizados y el que tu servidor funcione correctamente con estos métodos garantiza que cumple las funciones mínimas que se espera de un servidor HTTP.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Stress tests your server. It must stay available at all cost."</strong></p>
				<p>
					Es fundamental realizar pruebas de estrés para asegurar que tu servidor es capaz de soportar altas cargas y sigue respondiendo a las peticiones incluso bajo condiciones de estrés y carga máxima. El servidor debe ser capaz de manejar un gran volumen de peticiones simultáneas sin bloquearse o dejar de responder. La resiliencia y la capacidad de mantenerse disponible bajo estrés son requisitos esenciales para un servidor web.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Your server must be able to listen to multiple ports (see Configuration file)."</strong></p>
				<p>
					Tu servidor debe ser capaz de escuchar en múltiples puertos al mismo tiempo. Esto permite que un solo servidor pueda gestionar peticiones en diferentes puertos para diferentes propósitos o para simular múltiples servidores en la misma maquina.  Esta característica es fundamental para el correcto funcionamiento de tu servidor.  La configuración de qué puertos debe escuchar el servidor se especificará en el archivo de configuración.
				</p>
			</li>
		</ol>
		<label for="toogleReq">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION ARCHIVO DE CONFIGURACION -->

	<label for="toogleConfigFile">ARCHIVO DE CONFIGURACION</label>
	<input type="checkbox" id="toogleConfigFile" style="display: none;" >
	<section id="sectionConfigFile">
		<ul>
			<li>
				<p class="quote"><strong>"Choose the port and host of each ’server’."</strong></p>
				<p>
					Elige el puerto y el host de cada servidor. Esto define en qué direcciones de red y puertos específicos tu servidor web estará escuchando conexiones entrantes. 
					<br><br>
					El <strong>host</strong> puede ser una dirección IP (como `127.0.0.1` para localhost o `192.168.1.100` para una dirección local en tu red) o un nombre de dominio (si tu servidor está en la web).  El <strong>puerto</strong> es un número (por ejemplo, 80 para HTTP o 443 para HTTPS) que identifica el servicio específico que el servidor ofrece en esa dirección. Configurar correctamente esto es fundamental para que los clientes puedan contactar a tu servidor.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Setup the server_names or not."</strong></p>
				<p>
					Configura los nombres de servidor (opcional). Los nombres de servidor, también conocidos como "server names" o "virtual hosts", permiten que un único servidor web (con un mismo host y puerto) responda a múltiples dominios diferentes. Por ejemplo, un solo servidor podría manejar tanto `www.miweb1.com` como `www.miweb2.com`, y el servidor sabría a qué contenido servir basándose en el `server_name` que el cliente especificó en la cabecera HTTP. Este mecanismo es esencial para el hosting compartido, donde múltiples sitios web residen en la misma infraestructura.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"The first server for a host:port will be the default for this host:port (that means it will answer to all the requests that don’t belong to an other server)."</strong></p>
				<p>
					El primer servidor configurado para un par host:puerto específico se convierte en el servidor <strong>predeterminado</strong> para ese par. Esto significa que, si una solicitud entrante no coincide con un `server_name` específico, será manejada por el primer servidor configurado para ese host y puerto. Es importante considerar este comportamiento al configurar tus servidores virtuales, ya que el primer servidor actuará como un "catch-all" para cualquier solicitud que no tenga una configuración más específica.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Setup default error pages."</strong></p>
				<p>
					Configura las páginas de error predeterminadas. Cuando ocurren errores durante el procesamiento de una solicitud HTTP (por ejemplo, un error 404 "No encontrado" o un error 500 "Error interno del servidor"), es crucial tener páginas de error personalizadas para ofrecer una experiencia de usuario amigable. Configurar estas páginas permite que tu servidor responda de manera controlada ante situaciones imprevistas, en lugar de mostrar errores predeterminados y poco descriptivos.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Limit client body size."</strong></p>
				<p>
					Limita el tamaño máximo del cuerpo (payload) de las solicitudes HTTP que tu servidor aceptará. Esta es una medida de seguridad importante para prevenir ataques de denegación de servicio (DoS) que intenten sobrecargar el servidor enviando grandes cantidades de datos en una sola solicitud. Además, limitar el tamaño de las solicitudes evita el consumo excesivo de recursos (memoria, ancho de banda) por parte del servidor.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Setup routes with one or multiple of the following rules/configuration (routes won’t be using regexp):"</strong></p>
				<p>
					Configura rutas. Una ruta define cómo tu servidor maneja las diferentes partes de las URLs. Estas rutas no usarán expresiones regulares, lo que significa que deben coincidir de forma exacta con una parte de la URL solicitada. Esto es para que tu servidor sepa qué hacer cuando un cliente solicita un recurso en una ruta específica.
				</p>
				<ul>
					<li>
						<p class="quote">"Define a list of accepted HTTP methods for the route."</p>
						<p>Define una lista de métodos HTTP aceptados para la ruta, como `GET` para obtener datos, `POST` para enviar datos, `PUT` para actualizar recursos, `DELETE` para eliminar, entre otros. Al definir una lista de métodos permitidos, se incrementa la seguridad del servidor, impidiendo que se utilicen métodos no deseados para manipular el recurso. Por ejemplo, una ruta que solo acepta `GET` rechaza cualquier solicitud con el método `POST`.</p>
					</li>
					<li>
						<p class="quote">"Define a HTTP redirection."</p>
						<p>Define una redirección HTTP. Esto permite que tu servidor dirija a los usuarios de una URL a otra. Las redirecciones son útiles para reorganizar la estructura del sitio web, cambiar de dominio, o redirigir tráfico de una URL obsoleta a una URL actualizada. Las redirecciones pueden ser temporales (302) o permanentes (301). Esta característica mantiene el trafico y permite al usuario encontrar la informacion que busca, incluso si el recurso se encuentra en otra ruta.</p>
					</li>
					<li>
						<p class="quote">"Define a directory or a file from where the file should be searched."</p>
						<p>Especifica el directorio o archivo base desde donde el servidor buscará los recursos solicitados. Cuando un cliente pide una URL, el servidor buscará el archivo correspondiente dentro del directorio o archivo especificado para esa ruta. Por ejemplo, si una ruta corresponde al directorio "/var/www/html", cuando el cliente pide "/index.html", el servidor buscará "/var/www/html/index.html".</p>
					</li>
					<li>
						<p class="quote">"Turn on or off directory listing."</p>
						<p>Activa o desactiva la opción de mostrar una lista del contenido de un directorio si no se solicita un archivo específico dentro de ese directorio. Habilitar el listado de directorio puede ser útil para servidores de archivos o pruebas, pero en la mayoria de los casos, puede ser un riesgo de seguridad si se exponen archivos no deseados.</p>
					</li>
					<li>
						<p class="quote">"Set a default file to answer if the request is a directory."</p>
						<p>Define un archivo por defecto (como `index.html` o `index.php`) que se servirá cuando la URL solicite un directorio en lugar de un archivo específico. Si se habilita esta configuración, cuando un usuario solicite `/directorio`, el servidor buscara el archivo default dentro del directorio, `/directorio/index.html` por ejemplo, en lugar de mostrar el listado del contenido del directorio (si estuviera habilitado).</p>
					</li>
					<li>
						<p class="quote">"Execute CGI based on certain file extension (for example .php)."</p>
						<p>Habilita la ejecución de programas CGI (Interfaz de Gateway Común) basados en la extensión del archivo solicitado. Los CGIs son programas que generan contenido dinámico para la web. Al configurar esta opción, cuando un usuario pide un recurso con la extensión definida (ejemplo, `.php`), el servidor invocara el CGI adecuado para procesar la petición y generar una respuesta dinamica. Esta funcionalidad permite integrar lenguajes como PHP, Python, u otros que puedan generar respuestas dinámicas a las peticiones del usuario.</p>
					</li>
					<li>
						<p class="quote">"Make it work with POST and GET methods."</p>
						<p>Asegura que una ruta funcione con los métodos HTTP `POST` (para enviar datos) y `GET` (para obtener datos). La mayoría de las peticiones suelen ser GET, pero si quieres que el usuario envie información, debes habilitar `POST`. Asegurarse de que una ruta sea capaz de manejar estos dos metodos es vital para que funciones como la creación de cuentas de usuario o la subida de archivos funcionen correctamente.</p>
					</li>
					<li>
						<p class="quote">"Make the route able to accept uploaded files and configure where they should be saved."</p>
						<p>Permite que la ruta acepte archivos subidos por los clientes y especifica dónde deben guardarse en el sistema de archivos del servidor. Esta funcionalidad es necesaria para formularios que requieren la subida de ficheros, como por ejemplo, una subida de imagen para perfil. Al definir la ruta para los ficheros subidos, te aseguras de que los ficheros estén almacenados en un directorio que sea accesible, seguro y consistente con el resto de la configuración de tu servidor.</p>
					</li>
				</ul>
			</li>
			<li>
				<p class="quote"><strong>"Do you wonder what a CGI is?"</strong></p>
				<p>¿Te preguntas qué es un CGI? Es un mecanismo para ejecutar programas en el servidor que generan contenido dinámico. Los CGI son la interfaz que permite comunicar el servidor web con un programa, este programa generara una salida que el servidor retornará al cliente. Los CGIs permiten la ejecución de scripts y programas que interactúan con la solicitud del cliente y generan contenido dinámico.</p>
			</li>
			<li>
				<p class="quote"><strong>"Because you won’t call the CGI directly, use the full path as PATH_INFO."</strong></p>
				<p>Debido a que no llamarás al CGI directamente, usa la ruta completa como <code>PATH_INFO</code>.  La variable de entorno <code>PATH_INFO</code> se usa para pasar información adicional sobre la ruta solicitada al programa CGI. Es una variable de entorno que contiene la parte de la URL que va después del nombre del script. Es importante pasar la información correctamente para que el script procese la petición correctamente.</p>
			</li>
			<li>
				<p class="quote"><strong>"Just remember that, for chunked request, your server needs to unchunk it, the CGI will expect EOF as end of the body."</strong></p>
				<p>Recuerda que, para solicitudes chunked, tu servidor debe descomponerlas, ya que el CGI espera un EOF como final del cuerpo. Las solicitudes *chunked* son aquellas que envían el cuerpo en partes (chunks) sin especificar el tamaño total del cuerpo. Tu servidor web debe reensamblar estos chunks y enviar el cuerpo completo al script CGI para que este lo procese. Para señalar el final del cuerpo al script CGI se usa un EOF (end of file). La omision de esta funcionalidad puede llevar a fallos y comportamientos erráticos del servidor.
				</p>
			</li>
			<li>
				<p class="quote"><strong>"Same things for the output of the CGI. If no content_length is returned from the CGI, EOF will mark the end of the returned data."</strong></p>
				<p>Lo mismo ocurre con la salida del CGI. Si no se devuelve <code>content_length</code>, EOF marcará el final de los datos devueltos. El servidor necesita conocer la longitud del contenido (Content-Length) de la respuesta generada por el CGI. Si el CGI no proporciona esta información, el servidor considerará que el final de la respuesta es el EOF (End Of File). Es importante que el CGI devuelva el `content-length` en la cabecera o que se asegure de que su output termine con un EOF.</p>
			</li>
			<li>
				<p class="quote"><strong>"Your program should call the CGI with the file requested as first argument."</strong></p>
				<p>Tu programa debe llamar al CGI con el archivo solicitado como primer argumento. El primer argumento del programa CGI debe ser la ruta al archivo solicitado. Por ejemplo, si el cliente pide `index.php`, el programa CGI recibirá `index.php` como primer argumento. Es importante pasar esta información para que el programa CGI pueda procesar la petición correctamente.</p>
			</li>
			<li>
				<p class="quote"><strong>"The CGI should be run in the correct directory for relative path file access."</strong></p>
				<p>El CGI debe ejecutarse en el directorio correcto para permitir el acceso a rutas relativas. Es importante que el CGI se ejecute en el directorio correcto para que pueda acceder a los archivos usando rutas relativas. Por ejemplo, si el script CGI espera un archivo en `./data.txt`, y este se ejecuta desde `/var/www/cgi-bin/` entonces el archivo se buscara en `/var/www/cgi-bin/data.txt`. En cambio si el CGI se ejecuta desde el directorio `/var/www/html/`, entonces buscara en `/var/www/html/data.txt`. El directorio desde donde se ejecuta el script CGI puede impactar en como este accede a los archivos.</p>
			</li>
			<li>
				<p class="quote"><strong>"Your server should work with one CGI (php-CGI, Python, and so forth)."</strong></p>
				<p>Tu servidor debe funcionar con al menos un CGI (como php-CGI, Python, etc.). Para esta practica debe asegurarse que tu servidor puede trabajar con al menos un programa CGI, como por ejemplo, PHP para generar contenido dinámico a las peticiones del cliente. La funcionalidad de soportar un CGI es fundamental para probar que el servidor es capaz de interactuar con un programa para generar contenido dinámico.</p>
			</li>
			<li>
				<p class="quote"><strong>"You must provide some configuration files and default basic files to test and demonstrate every feature works during evaluation."</strong></p>
				<p>Debes proporcionar algunos archivos de configuración y archivos básicos por defecto para probar y demostrar que todas las características funcionan durante la evaluación. Es importante proporcionar los archivos necesarios para que el evaluador pueda probar que todas las funcionalidades funcionan correctamente. Esto incluye archivos de configuración que el servidor utiliza y archivos de prueba.
				</p>
			</li>
		</ul>

		<blockquote class="infoquote">
			"If you’ve got a question about one behavior, you should compare your
			program behavior with NGINX’s.
			For example, check how does server_name work.
			We’ve shared with you a small tester. It’s not mandatory to pass it
			if everything works fine with your browser and tests, but it can help
			you hunt some bugs."
		</blockquote>
		<p>
			Si tienes dudas sobre cómo se comporta tu servidor en un caso específico, una buena práctica es comparar su comportamiento con el de NGINX, un servidor web de alto rendimiento ampliamente utilizado en la industria. Por ejemplo, si no estás seguro de cómo funciona el `server_name` (host virtual), configura un caso similar tanto en tu servidor como en NGINX y observa las diferencias y similitudes.  Esta comparación te ayudará a entender mejor los estándares de la industria y a asegurarte de que tu implementación cumple con las expectativas.  Además, se te proporciona un pequeño programa de pruebas para ayudarte a identificar errores de una forma más automática. Si bien no es obligatorio que superes este programa de pruebas, puede ser útil para detectar fallos que no son obvios en las pruebas manuales con el navegador. Utilízalo para verificar la funcionalidad de tu servidor.
		</p>
		
		<blockquote>
			"The important thing is resilience. Your server should never die."
		</blockquote>
		<p>
			La resiliencia es un aspecto fundamental de un servidor web confiable. Esto significa que tu servidor debe ser capaz de seguir funcionando y respondiendo a las peticiones, incluso si se producen errores inesperados, ataques de denegación de servicio, o si recibe un número elevado de peticiones simultáneas.  Un servidor resiliente no se bloquea ni deja de responder ante problemas, sino que maneja los errores de forma controlada y sigue operativo. Para lograr la resiliencia, considera implementar mecanismos para manejar excepciones, prevenir fugas de memoria, controlar el uso de recursos, y asegurarte de que el servidor no dependa de un único punto de fallo. En resumen, el servidor debe estar diseñado para sobrevivir incluso en las peores condiciones.
		</p>
		
		<blockquote>
			"Do not test with only one program. Write your tests with a more
			convenient language such as Python or Golang, and so forth."
		</blockquote>
		<p>
			Es fundamental no limitar las pruebas de tu servidor a un único programa o herramienta. Para asegurarte de que tu servidor funciona correctamente en diversas situaciones, debes escribir pruebas utilizando lenguajes de programación más convenientes y expresivos, como Python o Golang. Estos lenguajes suelen tener bibliotecas y frameworks que facilitan la creación de pruebas automatizadas y la simulación de diferentes tipos de solicitudes HTTP.  Además, el uso de diferentes lenguajes te permite detectar errores específicos que podrían pasar desapercibidos si solo usas un único programa de pruebas.  Considera también incluir pruebas de rendimiento y de estrés para comprobar que tu servidor puede manejar un gran número de peticiones sin fallar. La idea principal es que las pruebas deben ser lo más variadas posibles.
		</p>
	<label for="toogleConfigFile">COLAPSAR</label>
</section>
<hr>
	
	<!-- SECCION FUNCIONES-->

	<label for="toogleFuncs">FUNCIONES PERMITIDAS</label>
	<input type="checkbox" id="toogleFuncs" style="display: none;" >
	<section id="sectionFuncs">

	<!-- SUB SECCION PROCESOS-->
	<hr>
	<label for="toogleProcs">MANEJO DE PROCESOS</label>
	<pre><code class="functionList">execve, fork, waitcodeid, kill, signal</code></pre>
	<input type="checkbox" id="toogleProcs" style="display: none;" >
	<section id="sectionProcs">

	<h2>execve()</h2>
	<p><strong>Función:</strong> Ejecuta un programa reemplazando el proceso actual por uno nuevo.</p>
	<p><strong>Uso:</strong> Se utiliza para iniciar un nuevo proceso en lugar del proceso que lo llama.</p>
	<p><strong>Prototipo:</strong> La función <strong>execve()</strong> es utilizada para ejecutar programas en sistemas UNIX y reemplaza el proceso actual con el nuevo. Su prototipo es el siguiente:</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">execve</span>(<span class="types">const char</span> <span class="names">pathname</span>, <span class="types">char *const</span> <span class="names">argv[]</span>, <span class="types">char *const</span> <span class="names">envp[]</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>pathname</strong>: Ruta del archivo ejecutable.</li>
		<li><strong>argv</strong>: Arreglo de cadenas de caracteres que representan los argumentos del programa.</li>
		<li><strong>envp</strong>: Arreglo de cadenas de caracteres que representan las variables de entorno.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">-1</span> en caso de error, y no retorna nada si tiene éxito (el proceso actual es reemplazado).</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">char</span> <span class="names">*argv[]</span> = {<span class="data">"/bin/ls"</span>, <span class="data">"-l"</span>, <span class="data">NULL</span>};
	<span class="types">char</span> <span class="names">*envp[]</span> = {<span class="data">"PATH=/bin"</span>, <span class="data">NULL</span>};
	<span class="names">execve</span>(<span class="data">"/bin/ls"</span>, argv, envp);
	</code>
	</pre>

	<h2>fork()</h2>
	<p><strong>Función:</strong> Crea un nuevo proceso duplicando el proceso actual.</p>
	<p><strong>Uso:</strong> Se utiliza para crear un proceso hijo, y es esencial para la ejecución paralela en servidores.</p>
	<p><strong>Prototipo:</strong> La función <strong>fork()</strong> crea un nuevo proceso que es una copia casi idéntica del proceso padre:</p>
	<pre>
	<code>
	<span class="types">pid_t</span> <span class="names">fork</span>(<span class="types">void</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
	  <li><strong>Valor de retorno</strong>: 
		<ul>
		  <li>En el proceso padre, retorna el PID del hijo.</li>
		  <li>En el proceso hijo, retorna <span class="data">0</span>.</li>
		</ul>
	  </li>
	</ul>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">pid_t</span> <span class="names">pid</span> = <span class="names">fork</span>();
	<span class="keyword">if</span> (pid == <span class="data">0</span>) {
		<span class="comment">// Código del proceso hijo</span>
	} <span class="keyword">else</span> {
		<span class="comment">// Código del proceso padre</span>
	}
	</code>
	</pre>
	

	<h2>waitpid()</h2>
	<p><strong>Función:</strong> Espera a que un proceso hijo termine su ejecución.</p>
	<p><strong>Uso:</strong> Se usa para controlar y obtener el estado de terminación de los procesos hijos.</p>
	<p><strong>Prototipo:</strong> La función <strong>waitpid()</strong> se utiliza para esperar que termine un proceso hijo específico:</p>
	<pre>
	<code>
	<span class="types">pid_t</span> <span class="names">waitpid</span>(<span class="types">pid_t</span> <span class="names">pid</span>, <span class="types">int</span> <span class="names">status</span>, <span class="types">int</span> <span class="names">options</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
	<li><strong>pid</strong>: PID del proceso hijo que se espera. Si es <span class="data">-1</span>, espera a cualquiera de los procesos hijos.</li>
	<li><strong>status</strong>: Dirección de memoria donde se almacena el estado de salida del proceso hijo.</li>
	<li><strong>options</strong>: Opciones adicionales como <span class="data">WNOHANG</span> para no bloquear el proceso si no hay hijos listos.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el PID del proceso hijo que terminó, o <span class="data">-1</span> si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">pid_t</span> <span class="names">pid</span> = <span class="names">fork</span>();
	<span class="keyword">if</span> (pid == <span class="data">0</span>) {
		<span class="comment">// Código del hijo</span>
	} <span class="keyword">else</span> {
		<span class="types">int</span> <span class="names">status</span>;
		<span class="names">waitpid</span>(pid, &status, <span class="data">0</span>);
	}
	</code>
	</pre>

	<h2>kill()</h2>
	<p><strong>Función:</strong> Envía una señal a un proceso.</p>
	<p><strong>Uso:</strong> Se utiliza para enviar señales, como para terminar un proceso o interrumpirlo.</p>
	<p><strong>Prototipo:</strong> La función <strong>kill()</strong> se utiliza para enviar señales a un proceso específico:</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">kill</span>(<span class="types">pid_t</span> <span class="names">pid</span>, <span class="types">int</span> <span class="names">sig</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
	  <li><strong>pid</strong>: PID del proceso al que se le envía la señal. Puede ser <span class="data">0</span> para enviar a todos los procesos en el mismo grupo.</li>
	  <li><strong>sig</strong>: El número de la señal que se desea enviar, como <span class="data">SIGKILL</span> o <span class="data">SIGTERM</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="names">kill</span>(<span class="data">1234</span>, <span class="types">SIGKILL</span>);
	</code>
	</pre>


	<h2>signal()</h2>
	<p><strong>Función:</strong> Establece una función de manejo para una señal.</p>
	<p><strong>Uso:</strong> Se usa para capturar y manejar señales enviadas al proceso.</p>
	<p><strong>Prototipo:</strong> La función <strong>signal()</strong> se utiliza para establecer un controlador de señales para un proceso:</p>
	<pre>
	<code>
	<span class="types">void</span> <span class="names">signal</span>(<span class="types">int</span> <span class="names">sig</span>, <span class="types">void (*handler)(int)</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
	  <li><strong>sig</strong>: El número de la señal a manejar, como <span class="data">SIGINT</span> o <span class="data">SIGTERM</span>.</li>
	  <li><strong>handler</strong>: La función que se llamará cuando la señal sea recibida.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve la dirección de la función anterior que manejaba la señal, o <span class="data">SIG_ERR</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="names">signal</span>(<span class="types">SIGINT</span>, <span class="names">sig_handler</span>);
	</code>
	</pre>
	

	<label for="toogleProcs">COLAPSAR</label>
	</section>
	<hr>

	<!-- SUB SECCION SISTEMA DE ARCHIVOS-->

	<label for="toogleFileSys">SISTEMA DE ARCHIVOS</label>
	<pre><code class="functionList">open, close, read, write, access, stat, opendir, readdir, closedir, chdir, dup, dup2, pipe</code></pre>
	<input type="checkbox" id="toogleFileSys" style="display: none;" >
	<section id="sectionFileSys">


	<h2>open()</h2>
	<p><strong>Función:</strong> Abre un archivo y devuelve un descriptor de archivo.</p>
	<p><strong>Uso:</strong> Se utiliza para abrir archivos en distintos modos (lectura, escritura, etc.).</p>
	<p><strong>Prototipo:</strong> La función <strong>open()</strong> se utiliza para abrir un archivo y se especifica el modo de apertura.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">open</span>(<span class="types">const char</span> <span class="names">*path</span>, <span class="types">int</span> <span class="names">oflag</span>, <span class="types">mode_t</span> <span class="names">mode</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>path</strong>: Ruta del archivo a abrir.</li>
		<li><strong>oflag</strong>: Modos de apertura (por ejemplo, <span class="data">O_RDONLY</span>, <span class="data">O_WRONLY</span>, etc.).</li>
		<li><strong>mode</strong>: Permisos del archivo (por ejemplo, <span class="data">S_IRUSR</span>, <span class="data">S_IWUSR</span>), solo se usa si el archivo es creado.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el descriptor de archivo si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">fd</span> = <span class="functions">open</span>(<span class="data">"archivo.txt"</span>, <span class="types">O_RDONLY</span>);
	<span class="keyword">if</span> (<span class="names">fd</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al abrir el archivo"</span>);
	}
	</code>
	</pre>
	
	<h2>close()</h2>
	<p><strong>Función:</strong> Cierra un descriptor de archivo previamente abierto.</p>
	<p><strong>Uso:</strong> Es necesario cerrar los descriptores de archivo cuando ya no se van a usar.</p>
	<p><strong>Prototipo:</strong> La función <strong>close()</strong> cierra un descriptor de archivo abierto previamente con <strong>open()</strong> o funciones similares.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">close</span>(<span class="types">int</span> <span class="names">fd</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>fd</strong>: Descriptor de archivo a cerrar.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="keyword">if</span> (<span class="functions">close</span>(<span class="names">fd</span>) == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al cerrar el archivo"</span>);
	}
	</code>
	</pre>
	
	<h2>read()</h2>
	<p><strong>Función:</strong> Lee datos de un descriptor de archivo.</p>
	<p><strong>Uso:</strong> Utilizada para leer contenido de archivos o de sockets.</p>
	<p><strong>Prototipo:</strong> La función <strong>read()</strong> lee datos de un descriptor de archivo abierto previamente.</p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">read</span>(<span class="types">int</span> <span class="names">fd</span>, <span class="types">void</span> *<span class="names">buf</span>, <span class="types">size_t</span> <span class="names">count</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>fd</strong>: Descriptor de archivo desde el cual se va a leer.</li>
		<li><strong>buf</strong>: Buffer donde se almacenarán los datos leídos.</li>
		<li><strong>count</strong>: Número máximo de bytes a leer.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de bytes leídos, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">bytes_read</span> = <span class="functions">read</span>(<span class="names">fd</span>, <span class="names">buffer</span>, <span class="data">1024</span>);
	<span class="keyword">if</span> (<span class="names">bytes_read</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al leer el archivo"</span>);
	}
	</code>
	</pre>
	
	<h2>write()</h2>
	<p><strong>Función:</strong> Escribe datos en un descriptor de archivo.</p>
	<p><strong>Uso:</strong> Se utiliza para escribir en archivos, sockets, etc.</p>
	<p><strong>Prototipo:</strong> La función <strong>write()</strong> escribe datos en un descriptor de archivo abierto previamente.</p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">write</span>(<span class="types">int</span> <span class="names">fd</span>, <span class="types">const void</span> *<span class="names">buf</span>, <span class="types">size_t</span> <span class="names">count</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>fd</strong>: Descriptor de archivo donde se escribirán los datos.</li>
		<li><strong>buf</strong>: Buffer que contiene los datos a escribir.</li>
		<li><strong>count</strong>: Número de bytes a escribir.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de bytes escritos, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">bytes_written</span> = <span class="functions">write</span>(<span class="names">fd</span>, <span class="names">buffer</span>, <span class="data">1024</span>);
	<span class="keyword">if</span> (<span class="names">bytes_written</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al escribir en el archivo"</span>);
	}
	</code>
	</pre>

	<h2>access()</h2>
	<p><strong>Función:</strong> Verifica los permisos de acceso de un archivo.</p>
	<p><strong>Uso:</strong> Se utiliza para comprobar si el proceso tiene acceso a un archivo con ciertos permisos (lectura, escritura, ejecución).</p>
	<p><strong>Prototipo:</strong> La función <strong>access()</strong> verifica los permisos de un archivo en el sistema de archivos.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">access</span>(<span class="types">const char</span> <span class="names">*path</span>, <span class="types">int</span> <span class="names">mode</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>path</strong>: Ruta del archivo cuya accesibilidad se va a verificar.</li>
		<li><strong>mode</strong>: Modo de acceso (por ejemplo, <span class="data">R_OK</span>, <span class="data">W_OK</span>, <span class="data">X_OK</span>).</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si el acceso es permitido, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">access</span>(<span class="data">"archivo.txt"</span>, <span class="types">R_OK</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"No se puede leer el archivo"</span>);
	}
	</code>
	</pre>
	
	<h2>stat()</h2>
	<p><strong>Función:</strong> Obtiene información sobre un archivo o directorio.</p>
	<p><strong>Uso:</strong> Se usa para obtener información detallada sobre un archivo, como tamaño, permisos, etc.</p>
	<p><strong>Prototipo:</strong> La función <strong>stat()</strong> obtiene el estado de un archivo o directorio.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">stat</span>(<span class="types">const char</span> <span class="names">*path</span>, <span class="types">struct stat</span> <span class="names">*buf</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>path</strong>: Ruta del archivo o directorio cuyo estado se va a obtener.</li>
		<li><strong>buf</strong>: Estructura que recibirá la información del archivo (tipo, permisos, tamaño, etc.).</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> en caso de éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct stat</span> <span class="names">file_info</span>;
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">stat</span>(<span class="data">"archivo.txt"</span>, &<span class="names">file_info</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al obtener el estado del archivo"</span>);
	}
	</code>
	</pre>
	
	<h2>opendir()</h2>
	<p><strong>Función:</strong> Abre un directorio para su lectura.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener un descriptor de directorio para poder leer su contenido.</p>
	<p><strong>Prototipo:</strong> La función <strong>opendir()</strong> abre un directorio y lo prepara para ser leído con funciones como <strong>readdir()</strong>.</p>
	<pre>
	<code>
	<span class="types">DIR</span> *<span class="names">opendir</span>(<span class="types">const char</span> <span class="names">*name</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>name</strong>: Ruta del directorio que se va a abrir.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un puntero a un objeto de tipo <span class="types">DIR</span> si tiene éxito, o <span class="data">NULL</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">DIR</span> *<span class="names">dir</span> = <span class="functions">opendir</span>(<span class="data">"/home/user"</span>);
	<span class="keyword">if</span> (<span class="names">dir</span> == <span class="data">NULL</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al abrir el directorio"</span>);
	}
	</code>
	</pre>
	
	<h2>readdir()</h2>
	<p><strong>Función:</strong> Lee una entrada de un directorio abierto.</p>
	<p><strong>Uso:</strong> Se usa para leer las entradas de un directorio, como los nombres de los archivos dentro del directorio.</p>
	<p><strong>Prototipo:</strong> La función <strong>readdir()</strong> devuelve una estructura que contiene información sobre la próxima entrada de un directorio.</p>
	<pre>
	<code>
	<span class="types">struct dirent</span> *<span class="names">readdir</span>(<span class="types">DIR</span> *<span class="names">dirp</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>dirp</strong>: Puntero a un directorio previamente abierto con <strong>opendir()</strong>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un puntero a una estructura <span class="types">dirent</span> si tiene éxito, o <span class="data">NULL</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct dirent</span> *<span class="names">entry</span>;
	<span class="keyword">while</span> ((<span class="names">entry</span> = <span class="functions">readdir</span>(<span class="names">dir</span>)) != <span class="data">NULL</span>) {
		<span class="types">printf</span>(<span class="data">"%s\n"</span>, <span class="names">entry</span>-<span class="names">d_name</span>);
	}
	</code>
	</pre>
	
	<h2>closedir()</h2>
	<p><strong>Función:</strong> Cierra un directorio previamente abierto.</p>
	<p><strong>Uso:</strong> Se utiliza para cerrar un descriptor de directorio cuando ya no se necesita.</p>
	<p><strong>Prototipo:</strong> La función <strong>closedir()</strong> cierra un directorio abierto previamente con <strong>opendir()</strong>.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">closedir</span>(<span class="types">DIR</span> *<span class="names">dirp</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>dirp</strong>: Puntero al directorio que se va a cerrar.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="keyword">if</span> (<span class="functions">closedir</span>(<span class="names">dir</span>) == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al cerrar el directorio"</span>);
	}
	</code>
	</pre>
	
	<h2>chdir()</h2>
	<p><strong>Función:</strong> Cambia el directorio de trabajo actual del proceso.</p>
	<p><strong>Uso:</strong> Se usa para cambiar el directorio de trabajo de un proceso en ejecución.</p>
	<p><strong>Prototipo:</strong> La función <strong>chdir()</strong> cambia el directorio de trabajo actual del proceso a la ruta especificada.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">chdir</span>(<span class="types">const char</span> <span class="names">*path</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>path</strong>: Ruta al nuevo directorio de trabajo.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">chdir</span>(<span class="data">"/home/user/Documents"</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al cambiar el directorio"</span>);
	}
	</code>
	</pre>


	<h2>dup()</h2>
	<p><strong>Función:</strong> Duplica un descriptor de archivo.</p>
	<p><strong>Uso:</strong> Se utiliza para crear una copia de un descriptor de archivo, permitiendo que ambos descriptores se refieran al mismo archivo o recurso.</p>
	<p><strong>Prototipo:</strong> La función <strong>dup()</strong> duplica un descriptor de archivo y devuelve un nuevo descriptor que apunta al mismo archivo o recurso.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">dup</span>(<span class="types">int</span> <span class="names">oldfd</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>oldfd</strong>: Descriptor de archivo existente que se va a duplicar.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un nuevo descriptor de archivo si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">newfd</span> = <span class="functions">dup</span>(<span class="data">1</span>);  <span class="comment">// Duplica el descriptor de archivo estándar de salida</span>
	<span class="keyword">if</span> (<span class="names">newfd</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al duplicar el descriptor"</span>);
	}
	</code>
	</pre>
	
	<h2>dup2()</h2>
	<p><strong>Función:</strong> Duplica un descriptor de archivo y lo asigna a un descriptor específico.</p>
	<p><strong>Uso:</strong> Similar a <strong>dup()</strong>, pero permite especificar el descriptor de archivo de destino.</p>
	<p><strong>Prototipo:</strong> La función <strong>dup2()</strong> duplica un descriptor de archivo y lo asigna a un descriptor específico.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">dup2</span>(<span class="types">int</span> <span class="names">oldfd</span>, <span class="types">int</span> <span class="names">newfd</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>oldfd</strong>: Descriptor de archivo existente que se va a duplicar.</li>
		<li><strong>newfd</strong>: Nuevo descriptor de archivo al que se asignará el duplicado.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el nuevo descriptor de archivo si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">dup2</span>(<span class="data">0</span>, <span class="data">2</span>);  <span class="comment">// Duplica el descriptor de archivo estándar de entrada al estándar de error</span>
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al duplicar el descriptor"</span>);
	}
	</code>
	</pre>
	
	<h2>pipe()</h2>
	<p><strong>Función:</strong> Crea un canal de comunicación entre procesos mediante descriptores de archivo.</p>
	<p><strong>Uso:</strong> Se utiliza para crear una comunicación unidireccional entre procesos, permitiendo que un proceso escriba y otro lea.</p>
	<p><strong>Prototipo:</strong> La función <strong>pipe()</strong> crea un canal de comunicación que consta de dos descriptores de archivo, uno para leer y otro para escribir.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">pipe</span>(<span class="types">int</span> <span class="names">pipefd[2]</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>pipefd</strong>: Array de dos enteros que se usarán para los descriptores de archivo, uno para lectura y otro para escritura.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">pipefd[2]</span>;
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">pipe</span>(<span class="names">pipefd</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al crear el pipe"</span>);
	}
	</code>
	</pre>
	
	<label for="toogleProcs">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION SOCKETS-->

	<label for="toogleSockets">SOCKETS</label>
	<pre><code class="functionList">socket, accept, listen, send, recv, bind, connect, setsockopt, getsockname, socketpair</code></pre>
	<input type="checkbox" id="toogleSockets" style="display: none;" >
	<section id="sectionSockets">

	<h2>socket()</h2>
	<p><strong>Función:</strong> Crea un nuevo socket para la comunicación en red.</p>
	<p><strong>Uso:</strong> Es el punto de partida para establecer una conexión de red.</p>
	<p><strong>Prototipo:</strong> La función <strong>socket()</strong> crea un nuevo socket que puede ser usado para comunicación entre procesos a través de la red.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">socket</span>(<span class="types">int</span> <span class="names">domain</span>, <span class="types">int</span> <span class="names">type</span>, <span class="types">int</span> <span class="names">protocol</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>domain</strong>: El dominio de la comunicación, como <span class="data">AF_INET</span> para IPv4.</li>
		<li><strong>type</strong>: El tipo de socket, como <span class="data">SOCK_STREAM</span> para TCP.</li>
		<li><strong>protocol</strong>: El protocolo, generalmente se pasa como <span class="data">0</span> para que el sistema seleccione el adecuado según el tipo de socket.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un descriptor de archivo para el socket creado si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">server_fd</span> = <span class="functions">socket</span>(<span class="types">AF_INET</span>, <span class="types">SOCK_STREAM</span>, <span class="data">0</span>);
	<span class="keyword">if</span> (<span class="names">server_fd</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"socket failed"</span>);
	}
	</code>
	</pre>
	
	<h2>accept()</h2>
	<p><strong>Función:</strong> Acepta una conexión entrante en un socket de escucha.</p>
	<p><strong>Uso:</strong> Se utiliza en el lado del servidor para aceptar las conexiones de los clientes.</p>
	<p><strong>Prototipo:</strong> La función <strong>accept()</strong> acepta una solicitud de conexión entrante en el socket de escucha.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">accept</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">struct sockaddr</span> <span class="names">*addr</span>, <span class="types">socklen_t</span> <span class="names">*addrlen</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket de escucha.</li>
		<li><strong>addr</strong>: Estructura donde se guardará la información de la conexión entrante.</li>
		<li><strong>addrlen</strong>: Tamaño de la estructura <span class="names">addr</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un descriptor de archivo para el socket de la conexión aceptada, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">new_socket</span> = <span class="functions">accept</span>(<span class="names">server_fd</span>, <span class="names">&client_addr</span>, <span class="names">&addr_len</span>);
	<span class="keyword">if</span> (<span class="names">new_socket</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"accept failed"</span>);
	}
	</code>
	</pre>
	
	<h2>listen()</h2>
	<p><strong>Función:</strong> Prepara un socket para aceptar conexiones entrantes.</p>
	<p><strong>Uso:</strong> Se utiliza en el lado del servidor para escuchar las solicitudes de conexión de los clientes.</p>
	<p><strong>Prototipo:</strong> La función <strong>listen()</strong> convierte un socket en un socket de escucha.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">listen</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">int</span> <span class="names">backlog</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket que se va a preparar para escuchar.</li>
		<li><strong>backlog</strong>: El número de conexiones que pueden estar en espera.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">listen</span>(<span class="names">server_fd</span>, <span class="data">10</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"listen failed"</span>);
	}
	</code>
	</pre>
	
	<h2>send()</h2>
	<p><strong>Función:</strong> Envía datos a través de un socket conectado.</p>
	<p><strong>Uso:</strong> Se utiliza para enviar datos desde el cliente al servidor o entre procesos.</p>
	<p><strong>Prototipo:</strong> La función <strong>send()</strong> envía datos a través de un socket conectado.</p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">send</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">const void</span> <span class="names">*buf</span>, <span class="types">size_t</span> <span class="names">len</span>, <span class="types">int</span> <span class="names">flags</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>buf</strong>: El búfer que contiene los datos a enviar.</li>
		<li><strong>len</strong>: La longitud de los datos a enviar.</li>
		<li><strong>flags</strong>: Opciones de envío, generalmente se pasa como <span class="data">0</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de bytes enviados, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">const</span> <span class="types">char</span> <span class="names">message</span>[] = <span class="data">"Hello, Server!"</span>;
	<span class="types">ssize_t</span> <span class="names">bytes_sent</span> = <span class="functions">send</span>(<span class="names">sockfd</span>, <span class="names">message</span>, <span class="data">strlen</span>(<span class="names">message</span>), <span class="data">0</span>);
	<span class="keyword">if</span> (<span class="names">bytes_sent</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"send failed"</span>);
	}
	</code>
	</pre>
	
	<h2>recv()</h2>
	<p><strong>Función:</strong> Recibe datos a través de un socket conectado.</p>
	<p><strong>Uso:</strong> Se utiliza para recibir datos de un socket, generalmente usado en el lado del servidor o en el receptor de datos.</p>
	<p><strong>Prototipo:</strong> La función <strong>recv()</strong> recibe datos de un socket conectado.</p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">recv</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">void</span> <span class="names">*buf</span>, <span class="types">size_t</span> <span class="names">len</span>, <span class="types">int</span> <span class="names">flags</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>buf</strong>: El búfer donde se almacenarán los datos recibidos.</li>
		<li><strong>len</strong>: La longitud máxima de los datos a recibir.</li>
		<li><strong>flags</strong>: Opciones de recepción, generalmente se pasa como <span class="data">0</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de bytes recibidos, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">char</span> <span class="names">buffer</span>[<span class="data">1024</span>];
	<span class="types">ssize_t</span> <span class="names">bytes_received</span> = <span class="functions">recv</span>(<span class="names">sockfd</span>, <span class="names">buffer</span>, <span class="data">1024</span>, <span class="data">0</span>);
	<span class="keyword">if</span> (<span class="names">bytes_received</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"recv failed"</span>);
	}
	</code>
	</pre>

	<h2>bind()</h2>
	<p><strong>Función:</strong> Asocia un socket con una dirección local.</p>
	<p><strong>Uso:</strong> Se utiliza para asociar un socket con una dirección específica (como una dirección IP y un puerto) en el servidor.</p>
	<p><strong>Prototipo:</strong> La función <strong>bind()</strong> asocia un socket con una dirección y puerto especificados en el servidor.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">bind</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">const struct sockaddr</span> <span class="names">*addr</span>, <span class="types">socklen_t</span> <span class="names">addrlen</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>addr</strong>: La dirección con la que se desea asociar el socket (estructura de tipo <span class="types">struct sockaddr</span>).</li>
		<li><strong>addrlen</strong>: El tamaño de la estructura <span class="names">addr</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct sockaddr_in</span> <span class="names">server_addr</span>;
	<span class="types">memset</span>(&<span class="names">server_addr</span>, <span class="data">0</span>, <span class="data">sizeof</span>(<span class="names">server_addr</span>));
	<span class="names">server_addr</span>.<span class="names">sin_family</span> = <span class="types">AF_INET</span>;
	<span class="names">server_addr</span>.<span class="names">sin_addr.s_addr</span> = <span class="data">INADDR_ANY</span>;
	<span class="names">server_addr</span>.<span class="names">sin_port</span> = <span class="data">htons</span>(<span class="data">8080</span>);
	
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">bind</span>(<span class="names">server_fd</span>, (<span class="types">struct sockaddr</span> *)&<span class="names">server_addr</span>, <span class="types">sizeof</span>(<span class="names">server_addr</span>));
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"bind failed"</span>);
	}
	</code>
	</pre>
	
	<h2>connect()</h2>
	<p><strong>Función:</strong> Establece una conexión a un socket remoto.</p>
	<p><strong>Uso:</strong> Se utiliza en el lado del cliente para establecer una conexión con el servidor.</p>
	<p><strong>Prototipo:</strong> La función <strong>connect()</strong> establece una conexión entre un socket y una dirección remota.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">connect</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">const struct sockaddr</span> <span class="names">*addr</span>, <span class="types">socklen_t</span> <span class="names">addrlen</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>addr</strong>: La dirección remota del servidor con el que se desea establecer la conexión.</li>
		<li><strong>addrlen</strong>: El tamaño de la estructura <span class="names">addr</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct sockaddr_in</span> <span class="names">server_addr</span>;
	<span class="names">server_addr</span>.<span class="names">sin_family</span> = <span class="types">AF_INET</span>;
	<span class="names">server_addr</span>.<span class="names">sin_port</span> = <span class="data">htons</span>(<span class="data">8080</span>);
	<span class="names">server_addr</span>.<span class="names">sin_addr.s_addr</span> = <span class="data">inet_addr</span>(<span class="data">"127.0.0.1"</span>);
	
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">connect</span>(<span class="names">sockfd</span>, (<span class="types">struct sockaddr</span> *)&<span class="names">server_addr</span>, <span class="types">sizeof</span>(<span class="names">server_addr</span>));
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"connect failed"</span>);
	}
	</code>
	</pre>
	
	<h2>setsockopt()</h2>
	<p><strong>Función:</strong> Establece opciones de socket.</p>
	<p><strong>Uso:</strong> Se utiliza para configurar las opciones de un socket, como los límites de tiempo de espera.</p>
	<p><strong>Prototipo:</strong> La función <strong>setsockopt()</strong> se usa para configurar opciones como el tiempo de espera en un socket.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">setsockopt</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">int</span> <span class="names">level</span>, <span class="types">int</span> <span class="names">optname</span>, <span class="types">const void</span> <span class="names">*optval</span>, <span class="types">socklen_t</span> <span class="names">optlen</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>level</strong>: El nivel de la opción (por ejemplo, <span class="data">SOL_SOCKET</span> para opciones de socket comunes).</li>
		<li><strong>optname</strong>: El nombre de la opción (por ejemplo, <span class="data">SO_REUSEADDR</span> para permitir la reutilización de direcciones).</li>
		<li><strong>optval</strong>: El valor de la opción.</li>
		<li><strong>optlen</strong>: El tamaño de la opción.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">reuse</span> = <span class="data">1</span>;
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">setsockopt</span>(<span class="names">sockfd</span>, <span class="types">SOL_SOCKET</span>, <span class="types">SO_REUSEADDR</span>, &<span class="names">reuse</span>, <span class="types">sizeof</span>(<span class="names">reuse</span>));
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"setsockopt failed"</span>);
	}
	</code>
	</pre>
	
	<h2>getsockname()</h2>
	<p><strong>Función:</strong> Obtiene la dirección local asociada a un socket.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener la dirección y el puerto local asociado a un socket.</p>
	<p><strong>Prototipo:</strong> La función <strong>getsockname()</strong> obtiene la dirección local de un socket conectado o enlazado.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">getsockname</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">struct sockaddr</span> <span class="names">*addr</span>, <span class="types">socklen_t</span> <span class="names">*addrlen</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>addr</strong>: Estructura donde se almacenará la dirección local.</li>
		<li><strong>addrlen</strong>: El tamaño de la estructura <span class="names">addr</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct sockaddr_in</span> <span class="names">local_addr</span>;
	<span class="types">socklen_t</span> <span class="names">addr_len</span> = <span class="types">sizeof</span>(<span class="names">local_addr</span>);
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">getsockname</span>(<span class="names">sockfd</span>, (<span class="types">struct sockaddr</span> *)&<span class="names">local_addr</span>, &<span class="names">addr_len</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"getsockname failed"</span>);
	}
	</code>
	</pre>
	
	<h2>socketpair()</h2>
	<p><strong>Función:</strong> Crea un par de sockets conectados.</p>
	<p><strong>Uso:</strong> Se utiliza para crear un par de sockets de comunicación entre dos procesos en la misma máquina.</p>
	<p><strong>Prototipo:</strong> La función <strong>socketpair()</strong> crea dos sockets conectados.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">socketpair</span>(<span class="types">int</span> <span class="names">domain</span>, <span class="types">int</span> <span class="names">type</span>, <span class="types">int</span> <span class="names">protocol</span>, <span class="types">int</span> <span class="names">sv[2]</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>domain</strong>: El dominio de la comunicación, como <span class="data">AF_UNIX</span>.</li>
		<li><strong>type</strong>: El tipo de socket, generalmente <span class="data">SOCK_STREAM</span>.</li>
		<li><strong>protocol</strong>: El protocolo, generalmente se pasa como <span class="data">0</span>.</li>
		<li><strong>sv</strong>: Un arreglo que almacenará los descriptores de archivo de los dos sockets.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">sv[2]</span>;
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">socketpair</span>(<span class="types">AF_UNIX</span>, <span class="types">SOCK_STREAM</span>, <span class="data">0</span>, <span class="names">sv</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"socketpair failed"</span>);
	}
	</code>
	</pre>
	
	<label for="toogleSockets">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION DIRECCIONES DE RED-->

	<label for="toogleAddress">DIRECCIONES DE RED</label>
	<pre><code class="functionList">getaddrinfo, freeaddrinfo, gai_strerror, getprotobyname, htons, htonl, ntohs, ntohl</code></pre>
	<input type="checkbox" id="toogleAddress" style="display: none;" >
	<section id="sectionAddress">

	<h2>getaddrinfo()</h2>
	<p><strong>Función:</strong> Resuelve un nombre de host o una dirección IP en una lista de direcciones.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener direcciones y protocolos de red a partir de un nombre de dominio o dirección IP.</p>
	<p><strong>Prototipo:</strong> La función <strong>getaddrinfo()</strong> obtiene una lista de direcciones de red que coinciden con una solicitud específica, utilizando el sistema de nombres de dominio o una dirección IP.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">getaddrinfo</span>(<span class="types">const char</span> <span class="names">*node</span>, <span class="types">const char</span> <span class="names">*service</span>, <span class="types">const struct addrinfo</span> <span class="names">*hints</span>, <span class="types">struct addrinfo</span> <span class="names">**res</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>node</strong>: El nombre del host o la dirección IP.</li>
		<li><strong>service</strong>: El nombre del servicio o el puerto, como "http" o "8080".</li>
		<li><strong>hints</strong>: Un puntero a una estructura <span class="types">struct addrinfo</span> que especifica las condiciones que deben cumplir los resultados (como el tipo de socket).</li>
		<li><strong>res</strong>: Un puntero a una lista de resultados de tipo <span class="types">struct addrinfo</span> que será llenada con la información obtenida.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o un valor negativo en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct addrinfo</span> <span class="names">hints</span>, <span class="names">*res</span>;
	<span class="types">memset</span>(&<span class="names">hints</span>, <span class="data">0</span>, <span class="types">sizeof</span>(<span class="names">hints</span>));
	<span class="names">hints</span>.<span class="names">ai_family</span> = <span class="types">AF_INET</span>;  <span class="comment">// IPV4</span>
	<span class="names">hints</span>.<span class="names">ai_socktype</span> = <span class="types">SOCK_STREAM</span>;  <span class="comment">// TCP</span>
	
	<span class="types">int</span> <span class="names">status</span> = <span class="functions">getaddrinfo</span>(<span class="data">"www.example.com"</span>, <span class="data">"80"</span>, &<span class="names">hints</span>, &<span class="names">res</span>);
	<span class="keyword">if</span> (<span class="names">status</span> != <span class="data">0</span>) {
		<span class="functions">fprintf</span>(stderr, <span class="data">"getaddrinfo: %s\n"</span>, <span class="names">gai_strerror</span>(<span class="names">status</span>));
		<span class="keyword">return</span> <span class="data">1</span>;
	}
	</code>
	</pre>
	
	<h2>freeaddrinfo()</h2>
	<p><strong>Función:</strong> Libera la memoria asociada a una lista de direcciones obtenida con <strong>getaddrinfo()</strong>.</p>
	<p><strong>Uso:</strong> Se utiliza para liberar la memoria que fue previamente asignada por <strong>getaddrinfo()</strong>.</p>
	<p><strong>Prototipo:</strong> La función <strong>freeaddrinfo()</strong> libera una lista de direcciones obtenida por <strong>getaddrinfo()</strong>.</p>
	<pre>
	<code>
	<span class="types">void</span> <span class="names">freeaddrinfo</span>(<span class="types">struct addrinfo</span> <span class="names">*res</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>res</strong>: Un puntero a una lista de direcciones (<span class="types">struct addrinfo</span>) que debe ser liberada.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> No tiene valor de retorno.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="functions">freeaddrinfo</span>(<span class="names">res</span>);
	</code>
	</pre>
	
	<h2>gai_strerror()</h2>
	<p><strong>Función:</strong> Convierte un código de error de <strong>getaddrinfo()</strong> a una cadena de caracteres descriptiva.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener un mensaje de error legible a partir del código de error retornado por <strong>getaddrinfo()</strong>.</p>
	<p><strong>Prototipo:</strong> La función <strong>gai_strerror()</strong> devuelve una cadena que describe el error que ocurrió con <strong>getaddrinfo()</strong>.</p>
	<pre>
	<code>
	<span class="types">const char</span> *<span class="names">gai_strerror</span>(<span class="types">int</span> <span class="names">ecode</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>ecode</strong>: El código de error que se desea describir, que puede ser el valor retornado por <strong>getaddrinfo()</strong>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve una cadena de caracteres que describe el error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">status</span> = <span class="functions">getaddrinfo</span>(<span class="data">"nonexistent.domain"</span>, <span class="data">"80"</span>, &<span class="names">hints</span>, &<span class="names">res</span>);
	<span class="keyword">if</span> (<span class="names">status</span> != <span class="data">0</span>) {
		<span class="functions">fprintf</span>(stderr, <span class="data">"getaddrinfo: %s\n"</span>, <span class="names">gai_strerror</span>(<span class="names">status</span>));
	}
	</code>
	</pre>
	
	<h2>getprotobyname()</h2>
	<p><strong>Función:</strong> Obtiene el número de protocolo asociado a un nombre de protocolo.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener información sobre un protocolo a partir de su nombre, como "tcp" o "udp".</p>
	<p><strong>Prototipo:</strong> La función <strong>getprotobyname()</strong> obtiene la estructura de protocolo que corresponde a un nombre de protocolo.</p>
	<pre>
	<code>
	<span class="types">struct protoent</span> *<span class="names">getprotobyname</span>(<span class="types">const char</span> <span class="names">*name</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>name</strong>: El nombre del protocolo, como <span class="data">"tcp"</span> o <span class="data">"udp"</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un puntero a una estructura <span class="types">protoent</span> que contiene información sobre el protocolo, o <span class="data">NULL</span> si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct protoent</span> <span class="names">*proto</span>;
	<span class="names">proto</span> = <span class="functions">getprotobyname</span>(<span class="data">"tcp"</span>);
	<span class="keyword">if</span> (<span class="names">proto</span> == <span class="data">NULL</span>) {
		<span class="functions">perror</span>(<span class="data">"getprotobyname failed"</span>);
	} <span class="keyword">else</span> {
		<span class="functions">printf</span>(<span class="data">"Protocol number for TCP: %d\n"</span>, <span class="names">proto</span>.<span class="names">p_proto</span>);
	}
	</code>
	</pre>
	
	<h2>htons()</h2>
	<p><strong>Función:</strong> Convierte un valor de 16 bits de orden de bytes de host a orden de bytes de red (big-endian).</p>
	<p><strong>Uso:</strong> Se utiliza para convertir un valor de 16 bits a su formato adecuado para su transmisión a través de la red.</p>
	<p><strong>Prototipo:</strong> La función <strong>htons()</strong> convierte un valor de 16 bits desde el orden de bytes del host al orden de bytes de la red.</p>
	<pre>
	<code>
	<span class="types">uint16_t</span> <span class="names">htons</span>(<span class="types">uint16_t</span> <span class="names">hostshort</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>hostshort</strong>: El valor de 16 bits que se desea convertir de formato host a formato de red.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el valor convertido a orden de bytes de red.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">uint16_t</span> <span class="names">port</span> = <span class="data">8080</span>;
	<span class="types">uint16_t</span> <span class="names">network_port</span> = <span class="names">htons</span>(<span class="names">port</span>);
	</code>
	</pre>
	
	<h2>htonl()</h2>
	<p><strong>Función:</strong> Convierte un valor de 32 bits de orden de bytes de host a orden de bytes de red (big-endian).</p>
	<p><strong>Uso:</strong> Se utiliza para convertir un valor de 32 bits a su formato adecuado para su transmisión a través de la red.</p>
	<p><strong>Prototipo:</strong> La función <strong>htonl()</strong> convierte un valor de 32 bits desde el orden de bytes del host al orden de bytes de la red.</p>
	<pre>
	<code>
	<span class="types">uint32_t</span> <span class="names">htonl</span>(<span class="types">uint32_t</span> <span class="names">hostlong</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>hostlong</strong>: El valor de 32 bits que se desea convertir de formato host a formato de red.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el valor convertido a orden de bytes de red.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">uint32_t</span> <span class="names">ip_address</span> = <span class="data">0x7f000001</span>; <span class="comment">// 127.0.0.1 en hexadecimal</span>
	<span class="types">uint32_t</span> <span class="names">network_ip</span> = <span class="names">htonl</span>(<span class="names">ip_address</span>);
	</code>
	</pre>
	
	<h2>ntohs()</h2>
	<p><strong>Función:</strong> Convierte un valor de 16 bits de orden de bytes de red a orden de bytes de host.</p>
	<p><strong>Uso:</strong> Se utiliza para convertir un valor de 16 bits de formato de red a formato host, utilizado cuando se recibe información de la red.</p>
	<p><strong>Prototipo:</strong> La función <strong>ntohs()</strong> convierte un valor de 16 bits desde el orden de bytes de red al orden de bytes del host.</p>
	<pre>
	<code>
	<span class="types">uint16_t</span> <span class="names">ntohs</span>(<span class="types">uint16_t</span> <span class="names">netshort</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>netshort</strong>: El valor de 16 bits que se desea convertir de formato de red a formato host.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el valor convertido a orden de bytes del host.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">uint16_t</span> <span class="names">network_port</span> = <span class="data">0x1F90</span>; <span class="comment">// 8080 en hexadecimal (formato de red)
	<span class="types">uint16_t</span> <span class="names">host_port</span> = <span class="names">ntohs</span>(<span class="names">network_port</span>);
	</code>
	</pre>
	
	<h2>ntohl()</h2>
	<p><strong>Función:</strong> Convierte un valor de 32 bits de orden de bytes de red a orden de bytes de host.</p>
	<p><strong>Uso:</strong> Se utiliza para convertir un valor de 32 bits de formato de red a formato host, utilizado cuando se recibe información de la red.</p>
	<p><strong>Prototipo:</strong> La función <strong>ntohl()</strong> convierte un valor de 32 bits desde el orden de bytes de red al orden de bytes del host.</p>
	<pre>
	<code>
	<span class="types">uint32_t</span> <span class="names">ntohl</span>(<span class="types">uint32_t</span> <span class="names">netlong</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>netlong</strong>: El valor de 32 bits que se desea convertir de formato de red a formato host.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el valor convertido a orden de bytes del host.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">uint32_t</span> <span class="names">network_ip</span> = <span class="data">0x7f000001</span>; <span class="comment">// 127.0.0.1 en formato de red
	<span class="types">uint32_t</span> <span class="names">host_ip</span> = <span class="names">ntohl</span>(<span class="names">network_ip</span>);
	</code>
	</pre>
	
	<label for="toogleAddress">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION EVENTOS DE SISTEMA-->

	<label for="toogleEvents">EVENTOS DE SISTEMA</label>
	<pre><code class="functionList">select, poll, epoll, epoll_create, epoll_ctl, epoll_wait, kqueue, kevent</code></pre>
	<input type="checkbox" id="toogleEvents" style="display: none;" >
	<section id="sectionEvents">

	<h2>select()</h2>
	<p><strong>Función:</strong> Permite la supervisión de múltiples descriptores de archivo para ver si alguno de ellos está listo para la lectura, escritura o si ha ocurrido una excepción.</p>
	<p><strong>Uso:</strong> Se utiliza para gestionar la entrada/salida no bloqueante en múltiples descriptores de archivo, como sockets y archivos.</p>
	<p><strong>Prototipo:</strong> La función <strong>select()</strong> permite esperar hasta que uno o más descriptores de archivo sean accesibles para la lectura, escritura o si ha ocurrido alguna excepción.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">select</span>(<span class="types">int</span> <span class="names">nfds</span>, 
					<span class="types">fd_set *</span> <span class="names">readfds</span>, 
					<span class="types">fd_set *</span> <span class="names">writefds</span>, 
					<span class="types">fd_set *</span> <span class="names">exceptfds</span>, 
					<span class="types">struct timeval *</span> <span class="names">timeout</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>nfds</strong>: El valor más alto de descriptor de archivo más 1.</li>
		<li><strong>readfds</strong>: Conjunto de descriptores de archivo a verificar para lectura.</li>
		<li><strong>writefds</strong>: Conjunto de descriptores de archivo a verificar para escritura.</li>
		<li><strong>exceptfds</strong>: Conjunto de descriptores de archivo a verificar para excepciones.</li>
		<li><strong>timeout</strong>: Estructura de tiempo que especifica el máximo tiempo de espera.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de descriptores de archivo listos, o -1 si hay error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">fd_set</span> <span class="names">readfds</span>;
	<span class="types">struct timeval</span> <span class="names">timeout</span>;
	<span class="names">FD_ZERO</span>(&<span class="names">readfds</span>);
	<span class="names">FD_SET</span>(<span class="data">0</span>, &<span class="names">readfds</span>); <span class="comment">// 0 es stdin</span>
	<span class="names">timeout</span>.<span class="names">tv_sec</span> = <span class="data">5</span>;
	<span class="names">timeout</span>.<span class="names">tv_usec</span> = <span class="data">0</span>;
	
	<span class="types">int</span> <span class="names">ret</span> = <span class="names">select</span>(<span class="data">1</span>, &<span class="names">readfds</span>, <span class="names">NULL</span>, <span class="names">NULL</span>, &<span class="names">timeout</span>);
	<span class="keyword">if</span> (<span class="names">ret</span> == <span class="data">0</span>) {
		<span class="names">printf</span>(<span class="data">"Tiempo agotado"</span>);
	} <span class="keyword">else</span> {
		<span class="names">printf</span>(<span class="data">"Datos disponibles para leer"</span>);
	}
	</code>
	</pre>
	
	<h2>poll()</h2>
	<p><strong>Función:</strong> Similar a <strong>select()</strong>, se utiliza para esperar eventos en múltiples descriptores de archivo, pero usa una estructura diferente.</p>
	<p><strong>Uso:</strong> Se utiliza para gestionar la entrada/salida en múltiples descriptores de archivo de manera más eficiente que <strong>select()</strong> en algunas circunstancias.</p>
	<p><strong>Prototipo:</strong> La función <strong>poll()</strong> permite esperar hasta que uno o más descriptores de archivo estén listos para realizar operaciones de lectura, escritura o excepciones.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">poll</span>(<span class="types">struct pollfd *</span> <span class="names">fds</span>, 
					<span class="types">nfds_t</span> <span class="names">nfds</span>, 
					<span class="types">int</span> <span class="names">timeout</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>fds</strong>: Arreglo de estructuras <strong>pollfd</strong>, cada una de las cuales describe un descriptor de archivo.</li>
		<li><strong>nfds</strong>: Número de descriptores de archivo a verificar.</li>
		<li><strong>timeout</strong>: El tiempo de espera en milisegundos.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de descriptores de archivo que están listos, 0 si hay un timeout, o -1 en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct pollfd</span> <span class="names">fds</span>[<span class="data">1</span>];
	<span class="names">fds</span>[<span class="data">0</span>].<span class="names">fd</span> = <span class="data">0</span>; <span class="comment">// stdin</span>
	<span class="names">fds</span>[<span class="data">0</span>].<span class="names">events</span> = <span class="data">POLLIN</span>;
	
	<span class="types">int</span> <span class="names">ret</span> = <span class="names">poll</span>(&<span class="names">fds</span>, <span class="data">1</span>, <span class="data">5000</span>);
	<span class="keyword">if</span> (<span class="names">ret</span> == <span class="data">0</span>) {
		<span class="names">printf</span>(<span class="data">"Tiempo agotado"</span>);
	} <span class="keyword">else if</span> (<span class="names">fds</span>[<span class="data">0</span>].<span class="names">revents</span> & <span class="data">POLLIN</span>) {
		<span class="names">printf</span>(<span class="data">"Datos disponibles para leer"</span>);
	}
	</code>
	</pre>

	<h2>epoll_create()</h2>
	<p><strong>Función:</strong> Crea una instancia de epoll, un mecanismo eficiente para monitorear múltiples descriptores de archivo en sistemas Linux.</p>
	<p><strong>Uso:</strong> Se utiliza para crear un archivo especial que se utiliza para realizar un seguimiento de los eventos en varios descriptores de archivo, mejorando la eficiencia respecto a `select()` y `poll()`.</p>
	<p><strong>Prototipo:</strong> La función <strong>epoll_create()</strong> crea un objeto epoll que será utilizado posteriormente para monitorear eventos en múltiples descriptores de archivo.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">epoll_create</span>(<span class="types">int</span> <span class="names">size</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>size</strong>: Aproximación del número máximo de descriptores que se monitorearán. Aunque el tamaño no es limitante, es una sugerencia para la implementación.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un descriptor de archivo para el nuevo objeto epoll, o -1 si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">epoll_fd</span> = <span class="names">epoll_create</span>(<span class="data">10</span>);
	<span class="keyword">if</span> (<span class="names">epoll_fd</span> == <span class="data">-1</span>) {
		<span class="names">perror</span>(<span class="data">"epoll_create error"</span>);
	}
	</code>
	</pre>
	
	<h2>epoll_ctl()</h2>
	<p><strong>Función:</strong> Controla la instancia de epoll para agregar, eliminar o modificar descriptores de archivo que se monitorean.</p>
	<p><strong>Uso:</strong> Se utiliza para modificar los descriptores de archivo registrados en un objeto epoll, especificando qué eventos deben ser monitoreados para cada descriptor.</p>
	<p><strong>Prototipo:</strong> La función <strong>epoll_ctl()</strong> se usa para registrar, eliminar o modificar los descriptores de archivo que deben ser monitoreados.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">epoll_ctl</span>(<span class="types">int</span> <span class="names">epoll_fd</span>, 
					<span class="types">int</span> <span class="names">op</span>, 
					<span class="types">int</span> <span class="names">fd</span>, 
					<span class="types">struct epoll_event *</span> <span class="names">event</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>epoll_fd</strong>: Descriptor del objeto epoll.</li>
		<li><strong>op</strong>: Operación a realizar: <strong>EPOLL_CTL_ADD</strong>, <strong>EPOLL_CTL_MOD</strong>, o <strong>EPOLL_CTL_DEL</strong>.</li>
		<li><strong>fd</strong>: Descriptor del archivo a modificar.</li>
		<li><strong>event</strong>: Estructura que especifica los eventos que se deben monitorear para el descriptor.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve 0 en caso de éxito, o -1 si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct epoll_event</span> <span class="names">event</span>;
	<span class="names">event</span>.<span class="names">events</span> = <span class="data">EPOLLIN</span>;
	<span class="names">event</span>.<span class="names">data</span>.<span class="names">fd</span> = <span class="data">stdin</span>;
	
	<span class="types">int</span> <span class="names">ret</span> = <span class="names">epoll_ctl</span>(<span class="names">epoll_fd</span>, <span class="data">EPOLL_CTL_ADD</span>, <span class="data">0</span>, &<span class="names">event</span>);
	<span class="keyword">if</span> (<span class="names">ret</span> == <span class="data">-1</span>) {
		<span class="names">perror</span>(<span class="data">"epoll_ctl error"</span>);
	}
	</code>
	</pre>
	
	<h2>epoll_wait()</h2>
	<p><strong>Función:</strong> Bloquea el programa y espera eventos en los descriptores de archivo registrados en un objeto epoll.</p>
	<p><strong>Uso:</strong> Se utiliza para esperar los eventos que han ocurrido en los descriptores de archivo monitoreados por un objeto epoll.</p>
	<p><strong>Prototipo:</strong> La función <strong>epoll_wait()</strong> espera eventos en los descriptores registrados y los devuelve cuando están disponibles.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">epoll_wait</span>(<span class="types">int</span> <span class="names">epoll_fd</span>, 
					<span class="types">struct epoll_event *</span> <span class="names">events</span>, 
					<span class="types">int</span> <span class="names">maxevents</span>, 
					<span class="types">int</span> <span class="names">timeout</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>epoll_fd</strong>: Descriptor del objeto epoll.</li>
		<li><strong>events</strong>: Arreglo de estructuras <strong>epoll_event</strong> para recibir los eventos.</li>
		<li><strong>maxevents</strong>: Número máximo de eventos que se pueden devolver.</li>
		<li><strong>timeout</strong>: Tiempo de espera en milisegundos (0 para no bloquear, -1 para esperar indefinidamente).</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de eventos ocurridos, 0 si ha ocurrido un timeout, o -1 si hay un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct epoll_event</span> <span class="names">events</span>[<span class="data">10</span>];
	<span class="types">int</span> <span class="names">num_events</span> = <span class="names">epoll_wait</span>(<span class="names">epoll_fd</span>, <span class="names">events</span>, 
													  <span class="data">10</span>, <span class="data">-1</span>);
	
	<span class="keyword">for</span> (<span class="types">int</span> <span class="names">i</span> = <span class="data">0</span>; <span class="names">i</span> < <span class="names">num_events</span>; <span class="names">i</span>++) {
		<span class="keyword">if</span> (events[i].<span class="names">events</span> & <span class="data">EPOLLIN</span>) {
			<span class="names">printf</span>(<span class="data">"Evento de lectura disponible"</span>);
		}
	}
	</code>
	</pre>
	
	<h2>kqueue()</h2>
	<p><strong>Función:</strong> Crea una instancia de un kqueue, un mecanismo de notificación de eventos utilizado en sistemas BSD.</p>
	<p><strong>Uso:</strong> Se utiliza para crear un objeto kqueue que puede ser utilizado para monitorear eventos en descriptores de archivo, señales y otras notificaciones.</p>
	<p><strong>Prototipo:</strong> La función <strong>kqueue()</strong> se usa para crear un descriptor de archivo especial que puede ser utilizado para gestionar eventos en un sistema.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">kqueue</span>(<span class="types">void</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li>Esta función no toma parámetros. Devuelve un descriptor de archivo que se utiliza para gestionar eventos en un sistema.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un descriptor de archivo para el objeto kqueue, o -1 si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">kq</span> = <span class="names">kqueue</span>();
	<span class="keyword">if</span> (<span class="names">kq</span> == <span class="data">-1</span>) {
		<span class="names">perror</span>(<span class="data">"kqueue error"</span>);
	}
	</code>
	</pre>
	
	<h2>kevent()</h2>
	<p><strong>Función:</strong> Modifica o espera eventos de un objeto kqueue, que puede ser utilizado para monitorear cambios en descriptores de archivo, señales, y otros eventos del sistema.</p>
	<p><strong>Uso:</strong> Se utiliza para añadir, eliminar o modificar eventos en un kqueue, o para bloquear y esperar eventos.</p>
	<p><strong>Prototipo:</strong> La función <strong>kevent()</strong> se usa para modificar un conjunto de eventos o esperar eventos en el kqueue.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">kevent</span>(<span class="types">int</span> <span class="names">kq</span>, 
					<span class="types">const struct kevent *</span> <span class="names">changelist</span>, 
					<span class="types">int</span> <span class="names">nchanges</span>, 
					<span class="types">struct kevent *</span> <span class="names">eventlist</span>, 
					<span class="types">int</span> <span class="names">nevents</span>, 
					<span class="types">const struct timespec *</span> <span class="names">timeout</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>kq</strong>: Descriptor del objeto kqueue.</li>
		<li><strong>changelist</strong>: Lista de eventos que se deben agregar o modificar en el kqueue.</li>
		<li><strong>nchanges</strong>: Número de eventos en la lista changelist.</li>
		<li><strong>eventlist</strong>: Lista donde se almacenan los eventos que ocurren.</li>
		<li><strong>nevents</strong>: Número máximo de eventos que se pueden almacenar en eventlist.</li>
		<li><strong>timeout</strong>: Tiempo de espera para bloquear la función. Si es NULL, se bloquea indefinidamente.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de eventos que se han activado, o -1 si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct kevent</span> <span class="names">kev</span>;
	<span class="names">EV_SET</span>(&<span class="names">kev</span>, <span class="data">0</span>, <span class="data">EVFILT_READ</span>, <span class="data">EV_ADD</span>, <span class="data">0</span>, <span class="data">0</span>, <span class="data">NULL</span>);
	
	<span class="types">int</span> <span class="names">ret</span> = <span class="names">kevent</span>(<span class="names">kq</span>, &<span class="names">kev</span>, <span class="data">1</span>, &<span class="names">kev</span>, <span class="data">1</span>, <span class="data">NULL</span>);
	
	<span class="keyword">if</span> (<span class="names">ret</span> == <span class="data">-1</span>) {
		<span class="names">perror</span>(<span class="data">"kevent error"</span>);
	}
	</code>
	</pre>
	
	<label for="toogleEvents">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION ERRORES DE SISTEMA-->

	<label for="toogleErrors">ERRORES DE SISTEMA</label>
	<pre><code class="functionList">strerror, errno</code></pre>
	<input type="checkbox" id="toogleErrors" style="display: none;" >
	<section id="sectionErrors">

	<h2>strerror()</h2>
	<p><strong>Función:</strong> Devuelve una cadena de texto que describe un código de error.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener una descripción legible para humanos de los errores que produce una función del sistema o una llamada de biblioteca.</p>
	<p><strong>Prototipo:</strong> La función <strong>strerror()</strong> toma un código de error y devuelve un mensaje descriptivo.</p>
	<pre>
	<code>
	<span class="types">char *</span> <span class="names">strerror</span>(<span class="types">int</span> <span class="names">errnum</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>errnum</strong>: El código de error que se quiere traducir a texto.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un puntero a una cadena que contiene el mensaje de error correspondiente al código <strong>errnum</strong>.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">fd</span> = <span class="names">open</span>(<span class="data">"/nonexistent"</span>, <span class="data">O_RDONLY</span>);
	<span class="keyword">if</span> (<span class="names">fd</span> == <span class="data">-1</span>) {
		<span class="names">printf</span>(<span class="data">"Error: %s\n"</span>, <span class="names">strerror</span>(<span class="names">errno</span>));
	}
	</code>
	</pre>
	
	<h2>errno</h2>
	<p><strong>Variable:</strong> Es una variable global que contiene el código del último error producido por una función del sistema o llamada de biblioteca.</p>
	<p><strong>Uso:</strong> Se utiliza para diagnosticar errores después de una llamada al sistema o función que falla, proporcionando el código de error correspondiente.</p>
	<p><strong>Definición:</strong> La variable <strong>errno</strong> es declarada en el encabezado <code>&lt;errno.h&gt;</code>.</p>
	<pre>
	<code>
	<span class="keyword">extern</span> <span class="types">int</span> <span class="names">errno</span>;
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>errno</strong>: Contiene el código del último error producido. Su valor es sobrescrito por las funciones del sistema al ocurrir un error.</li>
	</ul>
	<p><strong>Notas:</strong></p>
	<ul>
		<li>Antes de invocar cualquier función que pueda modificar <strong>errno</strong>, asegúrate de reiniciarlo si necesitas distinguir entre múltiples errores consecutivos.</li>
	</ul>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">fd</span> = <span class="names">open</span>(<span class="data">"/nonexistent"</span>, <span class="data">O_RDONLY</span>);
	<span class="keyword">if</span> (<span class="names">fd</span> == <span class="data">-1</span>) {
		<span class="names">printf</span>(<span class="data">"Error code: %d\n"</span>, <span class="names">errno</span>);
	}
	</code>
	</pre>
	
	<label for="toogleErrors">COLAPSAR</label>
	</section>
	<hr>

	<label for="toogleFuncs">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION CONCEPTOS CLAVE -->

<!-- SECCION CONCEPTOS CLAVE -->

<label for="toogleConcepts">CONCEPTOS CLAVE</label>
<input type="checkbox" id="toogleConcepts" style="display: none;" >
<section id="sectionConcepts">
<hr>

	<!-- SECCION HTTP -->

	<label for="toogleHTTP">PROTOCOLO HTTP</label>
	<input type="checkbox" id="toogleHTTP" style="display: none;" >
	<section id="sectionHTTP">
		
		<h2>Introducción al Protocolo HTTP</h2>
		<p>
			El <strong>Protocolo de Transferencia de Hipertexto (HTTP)</strong> es la base de la comunicación en la World Wide Web. Es un protocolo de nivel de aplicación que define cómo los clientes (como navegadores web) y los servidores web intercambian información. HTTP se basa en un modelo de solicitud-respuesta, donde un cliente envía una solicitud a un servidor, y el servidor responde con los datos solicitados o un mensaje de error.
		</p>

		<h3>Conceptos Básicos de HTTP</h3>
		<ul>
			<li>
				<p><strong>Métodos HTTP:</strong> Definen la acción que el cliente quiere realizar. Algunos de los métodos más comunes son:
					<ul>
						<li><code>GET</code>: Solicita un recurso específico.</li>
						<li><code>POST</code>: Envía datos al servidor para su procesamiento.</li>
						<li><code>DELETE</code>: Solicita la eliminación de un recurso.</li>
						<li><code>PUT</code>: Solicita la actualización o creación de un recurso.</li>
					</ul>
				</p>
			</li>
			<li>
				<p><strong>URLs (Localizadores Uniformes de Recursos):</strong> Identifican de forma única cada recurso en la web, especificando el protocolo, el host y la ruta al recurso.</p>
			</li>
			<li>
				<p><strong>Encabezados HTTP:</strong> Son pares clave-valor que proporcionan información adicional sobre la solicitud o la respuesta, como el tipo de contenido, la codificación, cookies, etc.</p>
			</li>
			<li>
				<p><strong>Códigos de Estado HTTP:</strong> Números de tres dígitos que indican el resultado de la solicitud del cliente, como <code>200 OK</code>, <code>404 Not Found</code> o <code>500 Internal Server Error</code>.</p>
			</li>
			<li>
				<p><strong>Cuerpo (Body):</strong> Los datos que se envían con la solicitud (como en una petición `POST`) o que se envían en la respuesta (como el HTML de una página web).</p>
			</li>
		</ul>

		<h3>RFC (Request for Comments)</h3>
		<p>
			El protocolo HTTP se define formalmente en una serie de documentos llamados <strong>RFCs (Request for Comments)</strong>. Un RFC es un documento publicado por la IETF (Internet Engineering Task Force) que describe los estándares, protocolos y procedimientos para la Internet. Los RFCs son documentos públicos que describen los protocolos que hacen posible el funcionamiento de internet. El documento que define el protocolo HTTP se va actualizando periodicamente con las nuevas funcionalidades que se van incorporando.
			
		</p>
		 <p>Puedes encontrar la especificación oficial de la última versión (HTTP/1.1) en el siguiente enlace:</p>
		
		<a href="https://datatracker.ietf.org/doc/html/rfc9110" target="_blank">RFC 9110 - HTTP Semantics</a>
		<br>
		<a href="https://datatracker.ietf.org/doc/html/rfc9112" target="_blank">RFC 9112 - HTTP/1.1</a>
		
		<h3>Implementación Mínima para este Ejercicio</h3>
		<p>
			Para este ejercicio, debes concentrarte en implementar un subconjunto básico del protocolo HTTP/1.1. Los puntos clave para comenzar son:
		</p>
		 <ul>
			<li>
				<p><strong>Analizar la solicitud HTTP:</strong> Implementa el código necesario para procesar una solicitud HTTP básica, incluyendo el método HTTP (GET, POST, DELETE), la URL, y los encabezados necesarios (ej: host). Ten en cuenta que tu servidor NO necesita implementar parsing de chunked requests.</p>
			</li>
			  <li>
				 <p><strong>Generar la respuesta HTTP:</strong> Envía una respuesta HTTP válida con los encabezados necesarios, el código de estado correcto y el cuerpo de la respuesta. </p>
			</li>
			  <li>
				<p><strong>Soporte para archivos estáticos:</strong>  Sirve archivos HTML, CSS, imágenes etc. del sistema de archivos local.
				</p>
			</li>
			 <li>
				<p><strong>Soporte para CGIs:</strong> Implementa la comunicación con CGIs externos como PHP.</p>
			</li>
			   <li>
				<p><strong>Implementar los metodos:</strong> Soporta al menos los métodos <code>GET</code>, <code>POST</code>, y <code>DELETE</code>, junto con las funcionalidades de  subida de archivos y listado de directorios cuando sea necesario.
				</p>
			</li>
	   </ul>
	   <p>
		   Recuerda, no necesitas implementar todas las funcionalidades de HTTP para este proyecto, pero debes cumplir con los requerimientos mínimos y comprender los conceptos básicos.
		</p>

		<label for="toogleHTTP">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION CGI -->

	<label for="toogleCGI">COMMON GATEWAY INTERFACE (CGI)</label>
	<input type="checkbox" id="toogleCGI" style="display: none;" >
	<section id="sectionCGI">
		
		<h2>Introducción a CGI (Interfaz de Gateway Común)</h2>
		<p>
			<strong>CGI (Common Gateway Interface)</strong> es un protocolo que permite a los servidores web ejecutar programas externos para generar contenido dinámico. En lugar de servir solo archivos estáticos, los servidores pueden usar CGI para interactuar con scripts o programas que procesan datos, acceden a bases de datos, o realizan otras operaciones y generar una respuesta HTML dinamica. CGI actúa como un puente entre el servidor web y las aplicaciones dinámicas.
		</p>
		
		<h3>Conceptos Básicos de CGI</h3>
		<ul>
			 <li>
				<p><strong>Interacción con el Servidor:</strong> Cuando un cliente solicita un recurso que requiere contenido dinámico, el servidor web llama a un programa CGI, pasándole información sobre la solicitud.</p>
			</li>
			<li>
				<p><strong>Variables de Entorno:</strong> El servidor transmite información al programa CGI mediante variables de entorno, como el método HTTP utilizado, la URL solicitada, la ruta del script, datos del usuario, etc.</p>
			</li>
			 <li>
				<p><strong>Salida Estándar:</strong> El programa CGI genera el contenido dinámico a través de la salida estándar (stdout), y el servidor web lee esta salida para enviar la respuesta HTTP al cliente.</p>
			</li>
			 <li>
				 <p><strong>Tipos de CGIs:</strong> Pueden ser scripts en lenguajes como Python, PHP, Perl o programas compilados en C, C++, etc. Para este ejercicio, solo se solicita soportar un solo tipo de programa CGI.
				 </p>
			</li>
			 <li>
				 <p><strong>PATH_INFO:</strong> El servidor utiliza la variable de entorno <code>PATH_INFO</code> para pasar al CGI información adicional sobre la ruta solicitada, incluyendo la parte de la ruta que sigue a la ruta del script CGI. Esta variable es fundamental para que el CGI pueda acceder a los parámetros y las rutas que se le solicitan.
				</p>
			</li>
		</ul>

		<h3>Funcionamiento Básico de CGI</h3>
		<ol>
			<li>
				<p>El cliente envía una solicitud al servidor web, solicitando un recurso que debe ser generado dinámicamente (por ejemplo, un script `.php`).</p>
			</li>
			 <li>
				<p>El servidor web reconoce que el recurso es un script CGI y ejecuta el programa o script CGI correspondiente en un proceso separado.</p>
			</li>
			<li>
				<p>El servidor web pasa información sobre la petición al script CGI mediante variables de entorno y argumentos en la línea de comandos.</p>
			</li>
			 <li>
				<p>El script CGI procesa la petición y genera el contenido dinámico (normalmente en formato HTML). Este contenido lo envia a la salida estandar.</p>
			</li>
			 <li>
				 <p>El servidor web captura la salida estándar del script CGI y la envía de vuelta al cliente como una respuesta HTTP.</p>
			</li>
		</ol>
		
		 <h3>Implementación Mínima para este Ejercicio</h3>
		<p>
			Para este ejercicio, debes implementar el soporte básico para ejecutar CGIs. Los puntos clave son:
		</p>
		<ul>
			<li>
				<p><strong>Ejecución de CGIs:</strong> Implementa la lógica necesaria para ejecutar un programa o script CGI como un proceso separado (usando <code>fork</code> y <code>execve</code>), pasando la ruta del recurso como primer argumento al CGI.</p>
			</li>
			<li>
				<p><strong>Variables de Entorno:</strong> Asegúrate de configurar correctamente las variables de entorno que el CGI necesita, como <code>PATH_INFO</code>.</p>
			</li>
			<li>
				<p><strong>Captura de la salida:</strong> Redirige la salida estándar del script CGI a un buffer que luego será usado para generar la respuesta HTTP.</p>
			</li>
			 <li>
				 <p><strong>Manejo de Content-Length:</strong>  Si el CGI no proporciona el encabezado <code>Content-Length</code> en su salida, tu servidor debe detectar el fin de la salida mediante un EOF (end of file).</p>
			</li>
			 <li>
				 <p><strong>Ejecución en el directorio correcto:</strong> Asegúrate de que el script CGI se ejecute en el directorio correcto para que pueda acceder a archivos utilizando rutas relativas.
				 </p>
			</li>
			 <li>
				<p><strong>Descompresión de chunked request:</strong> Tu servidor debe ser capaz de descomprimir el cuerpo en caso de que sea un chunked request, ya que el CGI espera recibir el cuerpo completo.
				</p>
			</li>
		</ul>
		
		<p>
			Recuerda que tu servidor debe funcionar con al menos un tipo de CGI (como php-CGI), debes demostrar que la salida dinamica del script CGI es correctamente interpretada por el servidor y devuelta al cliente.
		</p>

		<label for="toogleCGI">COLAPSAR</label>
	</section>
	<hr>

	<label for="toogleConceptSockets">SOCKETS</label>
	<input type="checkbox" id="toogleConceptSockets" style="display: none;" >
	<section id="sectionConceptSockets">
		
		<h2>Introducción a Sockets</h2>
		<p>
			Un <strong>socket</strong> es un punto final de comunicación en una red, permitiendo que dos programas se comuniquen entre sí, ya sea en la misma máquina o a través de una red. En el contexto de un servidor web, los sockets son la herramienta fundamental para que el servidor acepte conexiones de clientes, intercambie datos y responda a las peticiones HTTP.
		</p>
		
		 <h3>Conceptos Básicos de Sockets</h3>
		<ul>
			<li>
				<p><strong>Tipos de Sockets:</strong> Existen varios tipos de sockets, pero en el contexto de un servidor web, los más relevantes son los <strong>sockets de flujo (stream sockets)</strong>, que utilizan el protocolo TCP. TCP garantiza que los datos lleguen en orden y sin errores, lo que es crucial para la comunicación HTTP.</p>
			</li>
			<li>
			   <p><strong>Dirección y Puerto:</strong> Cada socket tiene una dirección IP y un número de puerto asociados, que identifican de forma única el punto final de comunicación en la red. El servidor usa una combinación de dirección IP y puerto para escuchar las peticiones de los clientes.</p>
			</li>
			 <li>
				<p><strong>Sockets de Servidor y de Cliente:</strong> Un servidor crea un socket para escuchar las conexiones entrantes (socket de escucha). Cuando un cliente se conecta, el servidor crea un nuevo socket para manejar la comunicación con ese cliente específico (socket conectado).</p>
			</li>
			  <li>
				 <p><strong>Comunicación Bidireccional:</strong> Los sockets permiten la comunicación bidireccional. Es decir, tanto el cliente como el servidor pueden enviar y recibir datos a través del mismo socket.
				 </p>
			</li>
			<li>
				<p><strong>Descriptores de Archivo:</strong> En sistemas Unix-like (como Linux y macOS), los sockets se representan como descriptores de archivo, lo que permite utilizar funciones como <code>read</code> y <code>write</code> para la comunicación.</p>
			</li>
		</ul>

		<h3>Uso de Sockets en este Proyecto</h3>
		<p>
			En este proyecto, tu servidor web utilizará sockets para:
		</p>
		 <ol>
			<li>
				<p><strong>Escuchar Conexiones:</strong> Crear un socket de escucha en la dirección IP y el puerto configurados, esperando nuevas conexiones de clientes.</p>
			</li>
			 <li>
				<p><strong>Aceptar Conexiones:</strong> Cuando un cliente intenta conectarse, el servidor debe aceptar la conexión, creando un nuevo socket conectado para comunicarse con ese cliente específico.</p>
			</li>
			<li>
				<p><strong>Recibir Solicitudes HTTP:</strong> Leer los datos enviados por el cliente a través del socket. Estos datos contendrán la solicitud HTTP (método, URL, encabezados, cuerpo).</p>
			</li>
			  <li>
				<p><strong>Enviar Respuestas HTTP:</strong> Enviar la respuesta HTTP al cliente, incluyendo el código de estado, los encabezados y el cuerpo (el contenido HTML, JSON, etc.).</p>
			</li>
			 <li>
				<p><strong>Gestionar Múltiples Conexiones:</strong> Dado que tu servidor debe ser no bloqueante, debe usar la función <code>poll()</code> (o equivalente) para gestionar múltiples sockets de clientes simultáneamente.</p>
			</li>
		</ol>

		<h3>Funciones de C/C++ Relevantes</h3>
		 <p>
			Aquí tienes una lista de las funciones de C/C++ más importantes que necesitarás para trabajar con sockets en este proyecto:
		</p>
		<ul>
			<li>
			   <p><strong><code>socket()</code>:</strong> Crea un nuevo socket. Debes especificar el dominio (por ejemplo, <code>AF_INET</code> para IPv4), el tipo de socket (por ejemplo, <code>SOCK_STREAM</code> para TCP) y el protocolo.</p>
			</li>
			<li>
			   <p><strong><code>bind()</code>:</strong> Asocia el socket creado a una dirección IP y un puerto específicos. Es necesario llamarla en el socket que servirá como socket de escucha del servidor.</p>
			</li>
			<li>
				<p><strong><code>listen()</code>:</strong> Marca el socket como socket de escucha, indicando que el servidor está listo para aceptar conexiones entrantes.</p>
			</li>
			<li>
				<p><strong><code>accept()</code>:</strong> Acepta una conexión entrante y crea un nuevo socket (el socket conectado) para la comunicación con el cliente.  Esta función es bloqueante y debe usarse con cuidado.</p>
			 </li>
			 <li>
				 <p><strong><code>connect()</code>:</strong> (No utilizada directamente por tu servidor, pero útil para pruebas del cliente) Intenta conectarse a un servidor en una dirección IP y puerto específicos.</p>
			 </li>
			   <li>
				 <p><strong><code>send()</code> / <code>write()</code>:</strong> Envía datos a través del socket.</p>
			 </li>
			  <li>
				 <p><strong><code>recv()</code> / <code>read()</code>:</strong> Recibe datos a través del socket.</p>
			</li>
			 <li>
				<p><strong><code>close()</code>:</strong> Cierra un socket, liberando los recursos asociados.</p>
			 </li>
			  <li>
				<p><strong><code>poll()</code>:</strong> Permite monitorizar un conjunto de sockets para verificar si están disponibles para leer, escribir o si ha ocurrido algún error.  Esta es la función primordial de gestión de sockets no bloqueantes en este proyecto.</p>
			 </li>
			 <li>
				<p><strong><code>getaddrinfo()</code>:</strong>  Convierte nombres de host o direcciones IP en estructuras de direcciones de socket, facilitando el uso de sockets. </p>
			 </li>
		 </ul>
		 <p>
		   Recuerda que debes usar la función `poll()` (o equivalente) para gestionar todos los sockets de manera no bloqueante.
		</p>
		
		<label for="toogleConceptSockets">COLAPSAR</label>
	</section>
	<hr>

	<label for="toogleConcepts">COLAPSAR</label>
</section>
<hr>

