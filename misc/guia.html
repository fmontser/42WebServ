<!DOCTYPE html>
<html lang="es">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Guia 42WebServ</title>

	<style>
		body {
			font-family: Arial, sans-serif;
			background-color: #cecccc;
			padding-left: 2em;
		}

		h1 {
			color: #333;
		}

		p {
			font-size: 16px;
			line-height: 1.5;
		}

		section {
			padding-left: 1em;
			display: none;
		}

		#toogleReq:checked + #sectionReq {
			display: block;
		}

		#toogleLimits:checked + #sectionLimits {
			display: block;
		}

		#toogleFuncs:checked + #sectionFuncs {
			display: block;
		}

		#toogleProcs:checked + #sectionProcs {
			display: block;
		}

		#toogleFileSys:checked + #sectionFileSys {
			display: block;
		}

		#toogleSockets:checked + #sectionSockets {
			display: block;
		}

		#toogleAddress:checked + #sectionAddress {
			display: block;
		}

		#toogleEvents:checked + #sectionEvents {
			display: block;
		}

		#toogleErrors:checked + #sectionErrors {
			display: block;
		}
	
		label {
			cursor: pointer;
			color: rgb(61, 55, 215);
			font-weight: bold;
			text-decoration: underline;
			padding-left: 1em;
		}

		.functionList {
			text-wrap-mode: wrap;
			background-color: #a9a9a9;
			border-radius: 5px;
			font-family: 'Courier New', monospace;
			font-size: 12px;
		}

		/* SINTAXIS DE CODIGO */

		pre {
			background-color: #a9a9a9;
			border-radius: 5px;
			font-family: 'Courier New', monospace;
			font-size: 14px;
			overflow-x: auto;
			margin-right: 2em;
		}

		code {
			margin-left: 2em;
			color: black;
		}


		.keyword {
			color: #e8e539;
			font-weight: bold;
		}

		.functions {
			color: #3f4f7b;
			font-weight: bold;
		}

		.names {
			color: #68481f;
			font-weight: bold;
		}

		.data {
			color: #317912;
		}

		.types {
			color: #0013bc;
			font-weight: bold;
		}

		.comment {
			color: #ffffff;
		}

	</style>
</head>

<body>
	<h1 id="webserv-requerimientos-y-limitaciones">GUIA 42 WEBSERV:</h1>
	<p style="font-style: italic;">subject version: 21.2</p>
	<hr>

	<!-- SECCION LIMITACIONES-->

	<label for="toogleLimits">LIMITACIONES</label>
	<input type="checkbox" id="toogleLimits" style="display: none;" >
	<section id="sectionLimits">
		<h3 id="restricciones-t-cnicas">Restricciones técnicas</h3>
	<ul>
		<li>Prohibido usar <code>fork()</code> excepto para la ejecución de CGIs. </li>
		<li>No se puede usar <code>execve()</code> para invocar otro servidor web. </li>
		<li>Está prohibido realizar operaciones de lectura/escritura sin pasar por <code>poll()</code> (o equivalentes). </li>
	</ul>
	<h3 id="errores-cr-ticos">Errores críticos</h3>
	<ul>
		<li>El programa no debe cerrarse inesperadamente ni fallar en ninguna circunstancia (incluso en caso de falta de memoria).</li>
	</ul>
		<label for="toogleLimits">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION REQUERIMIENTOS-->

	<label for="toogleReq">REQUERIMIENTOS</label>
	<input type="checkbox" id="toogleReq" style="display: none;" >
	<section id="sectionReq">
		<h3 id="configuraci-n-b-sica">Configuración básica</h3>
		<ul>
			<li>El programa debe aceptar un archivo de configuración como argumento, o usar uno por defecto.</li>
			<li>El archivo de configuración debe permitir:
		<ul>
				<li>Elegir puerto y host para cada servidor.</li>
				<li>Configurar nombres de servidor ( <code>server_name</code>). </li>
				<li>Configurar páginas de error personalizadas.</li>
				<li>Limitar el tamaño del cuerpo de las solicitudes.</li>
				<li>Definir rutas específicas con opciones como: 
					<ul>
						<li>Métodos HTTP permitidos.</li>
						<li>Redirecciones HTTP.</li>
						<li>Directorios base o archivos para rutas.</li>
						<li>Habilitar/deshabilitar listado de directorios.</li>
						<li>Configurar archivos predeterminados para directorios.</li>
						<li>Habilitar soporte para subida de archivos y definir su destino.</li>
					</ul>
				</li>
		</ul>
			</li>
		</ul>
		<h3 id="http-y-funcionalidad-b-sica">HTTP y funcionalidad básica</h3>
		<ul>
			<li>Implementar soporte para los métodos HTTP: <strong>GET</strong>, <strong>POST</strong>, y <strong>DELETE</strong>. </li>
			<li>Responder con códigos HTTP precisos y con páginas de error por defecto si no se configuran personalizadas.</li>
			<li>Compatible con HTTP/1.1 y navegadores web.</li>
			<li>El servidor debe ser capaz de servir sitios web estáticos completos.</li>
		</ul>
		<h3 id="manejo-de-conexiones">Manejo de conexiones</h3>
		<ul>
			<li>Implementar I/O no bloqueante utilizando <code>poll()</code> o equivalentes (como <code>select()</code>, <code>epoll()</code>, o <code>kqueue</code>). </li>
			<li>Solo se permite un <code>poll()</code> (o equivalente) para todas las operaciones I/O. </li>
			<li>Manejar múltiples conexiones y permitir la escucha en múltiples puertos.</li>
		</ul>
		<h3 id="cgi">CGI</h3>
		<ul>
			<li>Soportar <strong>Common Gateway Interface (CGI)</strong> para ejecutar scripts como PHP o Python: <ul>
					<li>El servidor debe llamar al CGI con el archivo solicitado como primer argumento.</li>
					<li>Descomprimir solicitudes chunked y procesar la salida del CGI correctamente.</li>
				</ul>
			</li>
		</ul>
		<h3 id="robustez">Robustez</h3>
		<ul>
			<li>No debe bloquearse ni colgarse indefinidamente.</li>
			<li>Debe resistir pruebas de estrés manteniéndose disponible en todo momento.</li>
		</ul>
		<label for="toogleReq">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION FUNCIONES-->

	<label for="toogleFuncs">FUNCIONES PERMITIDAS</label>
	<input type="checkbox" id="toogleFuncs" style="display: none;" >
	<section id="sectionFuncs">

	<!-- SUB SECCION PROCESOS-->
	<hr>
	<label for="toogleProcs">MANEJO DE PROCESOS</label>
	<pre><code class="functionList">execve, fork, waitcodeid, kill, signal</code></pre>
	<input type="checkbox" id="toogleProcs" style="display: none;" >
	<section id="sectionProcs">

	<h2>execve()</h2>
	<p><strong>Función:</strong> Ejecuta un programa reemplazando el proceso actual por uno nuevo.</p>
	<p><strong>Uso:</strong> Se utiliza para iniciar un nuevo proceso en lugar del proceso que lo llama.</p>
	<p><strong>Prototipo:</strong> La función <strong>execve()</strong> es utilizada para ejecutar programas en sistemas UNIX y reemplaza el proceso actual con el nuevo. Su prototipo es el siguiente:</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">execve</span>(<span class="types">const char</span> <span class="names">pathname</span>, <span class="types">char *const</span> <span class="names">argv[]</span>, <span class="types">char *const</span> <span class="names">envp[]</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>pathname</strong>: Ruta del archivo ejecutable.</li>
		<li><strong>argv</strong>: Arreglo de cadenas de caracteres que representan los argumentos del programa.</li>
		<li><strong>envp</strong>: Arreglo de cadenas de caracteres que representan las variables de entorno.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">-1</span> en caso de error, y no retorna nada si tiene éxito (el proceso actual es reemplazado).</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">char</span> <span class="names">*argv[]</span> = {<span class="data">"/bin/ls"</span>, <span class="data">"-l"</span>, <span class="data">NULL</span>};
	<span class="types">char</span> <span class="names">*envp[]</span> = {<span class="data">"PATH=/bin"</span>, <span class="data">NULL</span>};
	<span class="names">execve</span>(<span class="data">"/bin/ls"</span>, argv, envp);
	</code>
	</pre>

	<h2>fork()</h2>
	<p><strong>Función:</strong> Crea un nuevo proceso duplicando el proceso actual.</p>
	<p><strong>Uso:</strong> Se utiliza para crear un proceso hijo, y es esencial para la ejecución paralela en servidores.</p>
	<p><strong>Prototipo:</strong> La función <strong>fork()</strong> crea un nuevo proceso que es una copia casi idéntica del proceso padre:</p>
	<pre>
	<code>
	<span class="types">pid_t</span> <span class="names">fork</span>(<span class="types">void</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
	  <li><strong>Valor de retorno</strong>: 
		<ul>
		  <li>En el proceso padre, retorna el PID del hijo.</li>
		  <li>En el proceso hijo, retorna <span class="data">0</span>.</li>
		</ul>
	  </li>
	</ul>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">pid_t</span> <span class="names">pid</span> = <span class="names">fork</span>();
	<span class="keyword">if</span> (pid == <span class="data">0</span>) {
		<span class="comment">// Código del proceso hijo</span>
	} <span class="keyword">else</span> {
		<span class="comment">// Código del proceso padre</span>
	}
	</code>
	</pre>
	

	<h2>waitpid()</h2>
	<p><strong>Función:</strong> Espera a que un proceso hijo termine su ejecución.</p>
	<p><strong>Uso:</strong> Se usa para controlar y obtener el estado de terminación de los procesos hijos.</p>
	<p><strong>Prototipo:</strong> La función <strong>waitpid()</strong> se utiliza para esperar que termine un proceso hijo específico:</p>
	<pre>
	<code>
	<span class="types">pid_t</span> <span class="names">waitpid</span>(<span class="types">pid_t</span> <span class="names">pid</span>, <span class="types">int</span> <span class="names">status</span>, <span class="types">int</span> <span class="names">options</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
	<li><strong>pid</strong>: PID del proceso hijo que se espera. Si es <span class="data">-1</span>, espera a cualquiera de los procesos hijos.</li>
	<li><strong>status</strong>: Dirección de memoria donde se almacena el estado de salida del proceso hijo.</li>
	<li><strong>options</strong>: Opciones adicionales como <span class="data">WNOHANG</span> para no bloquear el proceso si no hay hijos listos.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el PID del proceso hijo que terminó, o <span class="data">-1</span> si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">pid_t</span> <span class="names">pid</span> = <span class="names">fork</span>();
	<span class="keyword">if</span> (pid == <span class="data">0</span>) {
		<span class="comment">// Código del hijo</span>
	} <span class="keyword">else</span> {
		<span class="types">int</span> <span class="names">status</span>;
		<span class="names">waitpid</span>(pid, &status, <span class="data">0</span>);
	}
	</code>
	</pre>

	<h2>kill()</h2>
	<p><strong>Función:</strong> Envía una señal a un proceso.</p>
	<p><strong>Uso:</strong> Se utiliza para enviar señales, como para terminar un proceso o interrumpirlo.</p>
	<p><strong>Prototipo:</strong> La función <strong>kill()</strong> se utiliza para enviar señales a un proceso específico:</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">kill</span>(<span class="types">pid_t</span> <span class="names">pid</span>, <span class="types">int</span> <span class="names">sig</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
	  <li><strong>pid</strong>: PID del proceso al que se le envía la señal. Puede ser <span class="data">0</span> para enviar a todos los procesos en el mismo grupo.</li>
	  <li><strong>sig</strong>: El número de la señal que se desea enviar, como <span class="data">SIGKILL</span> o <span class="data">SIGTERM</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="names">kill</span>(<span class="data">1234</span>, <span class="types">SIGKILL</span>);
	</code>
	</pre>


	<h2>signal()</h2>
	<p><strong>Función:</strong> Establece una función de manejo para una señal.</p>
	<p><strong>Uso:</strong> Se usa para capturar y manejar señales enviadas al proceso.</p>
	<p><strong>Prototipo:</strong> La función <strong>signal()</strong> se utiliza para establecer un controlador de señales para un proceso:</p>
	<pre>
	<code>
	<span class="types">void</span> <span class="names">signal</span>(<span class="types">int</span> <span class="names">sig</span>, <span class="types">void (*handler)(int)</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
	  <li><strong>sig</strong>: El número de la señal a manejar, como <span class="data">SIGINT</span> o <span class="data">SIGTERM</span>.</li>
	  <li><strong>handler</strong>: La función que se llamará cuando la señal sea recibida.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve la dirección de la función anterior que manejaba la señal, o <span class="data">SIG_ERR</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="names">signal</span>(<span class="types">SIGINT</span>, <span class="names">sig_handler</span>);
	</code>
	</pre>
	

	<label for="toogleProcs">COLAPSAR</label>
	</section>
	<hr>

	<!-- SUB SECCION SISTEMA DE ARCHIVOS-->

	<label for="toogleFileSys">SISTEMA DE ARCHIVOS</label>
	<pre><code class="functionList">open, close, read, write, access, stat, opendir, readdir, closedir, chdir, dup, dup2, pipe</code></pre>
	<input type="checkbox" id="toogleFileSys" style="display: none;" >
	<section id="sectionFileSys">


	<h2>open()</h2>
	<p><strong>Función:</strong> Abre un archivo y devuelve un descriptor de archivo.</p>
	<p><strong>Uso:</strong> Se utiliza para abrir archivos en distintos modos (lectura, escritura, etc.).</p>
	<p><strong>Prototipo:</strong> La función <strong>open()</strong> se utiliza para abrir un archivo y se especifica el modo de apertura.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">open</span>(<span class="types">const char</span> <span class="names">*path</span>, <span class="types">int</span> <span class="names">oflag</span>, <span class="types">mode_t</span> <span class="names">mode</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>path</strong>: Ruta del archivo a abrir.</li>
		<li><strong>oflag</strong>: Modos de apertura (por ejemplo, <span class="data">O_RDONLY</span>, <span class="data">O_WRONLY</span>, etc.).</li>
		<li><strong>mode</strong>: Permisos del archivo (por ejemplo, <span class="data">S_IRUSR</span>, <span class="data">S_IWUSR</span>), solo se usa si el archivo es creado.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el descriptor de archivo si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">fd</span> = <span class="functions">open</span>(<span class="data">"archivo.txt"</span>, <span class="types">O_RDONLY</span>);
	<span class="keyword">if</span> (<span class="names">fd</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al abrir el archivo"</span>);
	}
	</code>
	</pre>
	
	<h2>close()</h2>
	<p><strong>Función:</strong> Cierra un descriptor de archivo previamente abierto.</p>
	<p><strong>Uso:</strong> Es necesario cerrar los descriptores de archivo cuando ya no se van a usar.</p>
	<p><strong>Prototipo:</strong> La función <strong>close()</strong> cierra un descriptor de archivo abierto previamente con <strong>open()</strong> o funciones similares.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">close</span>(<span class="types">int</span> <span class="names">fd</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>fd</strong>: Descriptor de archivo a cerrar.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="keyword">if</span> (<span class="functions">close</span>(<span class="names">fd</span>) == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al cerrar el archivo"</span>);
	}
	</code>
	</pre>
	
	<h2>read()</h2>
	<p><strong>Función:</strong> Lee datos de un descriptor de archivo.</p>
	<p><strong>Uso:</strong> Utilizada para leer contenido de archivos o de sockets.</p>
	<p><strong>Prototipo:</strong> La función <strong>read()</strong> lee datos de un descriptor de archivo abierto previamente.</p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">read</span>(<span class="types">int</span> <span class="names">fd</span>, <span class="types">void</span> *<span class="names">buf</span>, <span class="types">size_t</span> <span class="names">count</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>fd</strong>: Descriptor de archivo desde el cual se va a leer.</li>
		<li><strong>buf</strong>: Buffer donde se almacenarán los datos leídos.</li>
		<li><strong>count</strong>: Número máximo de bytes a leer.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de bytes leídos, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">bytes_read</span> = <span class="functions">read</span>(<span class="names">fd</span>, <span class="names">buffer</span>, <span class="data">1024</span>);
	<span class="keyword">if</span> (<span class="names">bytes_read</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al leer el archivo"</span>);
	}
	</code>
	</pre>
	
	<h2>write()</h2>
	<p><strong>Función:</strong> Escribe datos en un descriptor de archivo.</p>
	<p><strong>Uso:</strong> Se utiliza para escribir en archivos, sockets, etc.</p>
	<p><strong>Prototipo:</strong> La función <strong>write()</strong> escribe datos en un descriptor de archivo abierto previamente.</p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">write</span>(<span class="types">int</span> <span class="names">fd</span>, <span class="types">const void</span> *<span class="names">buf</span>, <span class="types">size_t</span> <span class="names">count</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>fd</strong>: Descriptor de archivo donde se escribirán los datos.</li>
		<li><strong>buf</strong>: Buffer que contiene los datos a escribir.</li>
		<li><strong>count</strong>: Número de bytes a escribir.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de bytes escritos, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">bytes_written</span> = <span class="functions">write</span>(<span class="names">fd</span>, <span class="names">buffer</span>, <span class="data">1024</span>);
	<span class="keyword">if</span> (<span class="names">bytes_written</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al escribir en el archivo"</span>);
	}
	</code>
	</pre>

	<h2>access()</h2>
	<p><strong>Función:</strong> Verifica los permisos de acceso de un archivo.</p>
	<p><strong>Uso:</strong> Se utiliza para comprobar si el proceso tiene acceso a un archivo con ciertos permisos (lectura, escritura, ejecución).</p>
	<p><strong>Prototipo:</strong> La función <strong>access()</strong> verifica los permisos de un archivo en el sistema de archivos.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">access</span>(<span class="types">const char</span> <span class="names">*path</span>, <span class="types">int</span> <span class="names">mode</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>path</strong>: Ruta del archivo cuya accesibilidad se va a verificar.</li>
		<li><strong>mode</strong>: Modo de acceso (por ejemplo, <span class="data">R_OK</span>, <span class="data">W_OK</span>, <span class="data">X_OK</span>).</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si el acceso es permitido, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">access</span>(<span class="data">"archivo.txt"</span>, <span class="types">R_OK</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"No se puede leer el archivo"</span>);
	}
	</code>
	</pre>
	
	<h2>stat()</h2>
	<p><strong>Función:</strong> Obtiene información sobre un archivo o directorio.</p>
	<p><strong>Uso:</strong> Se usa para obtener información detallada sobre un archivo, como tamaño, permisos, etc.</p>
	<p><strong>Prototipo:</strong> La función <strong>stat()</strong> obtiene el estado de un archivo o directorio.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">stat</span>(<span class="types">const char</span> <span class="names">*path</span>, <span class="types">struct stat</span> <span class="names">*buf</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>path</strong>: Ruta del archivo o directorio cuyo estado se va a obtener.</li>
		<li><strong>buf</strong>: Estructura que recibirá la información del archivo (tipo, permisos, tamaño, etc.).</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> en caso de éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct stat</span> <span class="names">file_info</span>;
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">stat</span>(<span class="data">"archivo.txt"</span>, &<span class="names">file_info</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al obtener el estado del archivo"</span>);
	}
	</code>
	</pre>
	
	<h2>opendir()</h2>
	<p><strong>Función:</strong> Abre un directorio para su lectura.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener un descriptor de directorio para poder leer su contenido.</p>
	<p><strong>Prototipo:</strong> La función <strong>opendir()</strong> abre un directorio y lo prepara para ser leído con funciones como <strong>readdir()</strong>.</p>
	<pre>
	<code>
	<span class="types">DIR</span> *<span class="names">opendir</span>(<span class="types">const char</span> <span class="names">*name</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>name</strong>: Ruta del directorio que se va a abrir.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un puntero a un objeto de tipo <span class="types">DIR</span> si tiene éxito, o <span class="data">NULL</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">DIR</span> *<span class="names">dir</span> = <span class="functions">opendir</span>(<span class="data">"/home/user"</span>);
	<span class="keyword">if</span> (<span class="names">dir</span> == <span class="data">NULL</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al abrir el directorio"</span>);
	}
	</code>
	</pre>
	
	<h2>readdir()</h2>
	<p><strong>Función:</strong> Lee una entrada de un directorio abierto.</p>
	<p><strong>Uso:</strong> Se usa para leer las entradas de un directorio, como los nombres de los archivos dentro del directorio.</p>
	<p><strong>Prototipo:</strong> La función <strong>readdir()</strong> devuelve una estructura que contiene información sobre la próxima entrada de un directorio.</p>
	<pre>
	<code>
	<span class="types">struct dirent</span> *<span class="names">readdir</span>(<span class="types">DIR</span> *<span class="names">dirp</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>dirp</strong>: Puntero a un directorio previamente abierto con <strong>opendir()</strong>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un puntero a una estructura <span class="types">dirent</span> si tiene éxito, o <span class="data">NULL</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct dirent</span> *<span class="names">entry</span>;
	<span class="keyword">while</span> ((<span class="names">entry</span> = <span class="functions">readdir</span>(<span class="names">dir</span>)) != <span class="data">NULL</span>) {
		<span class="types">printf</span>(<span class="data">"%s\n"</span>, <span class="names">entry</span>-<span class="names">d_name</span>);
	}
	</code>
	</pre>
	
	<h2>closedir()</h2>
	<p><strong>Función:</strong> Cierra un directorio previamente abierto.</p>
	<p><strong>Uso:</strong> Se utiliza para cerrar un descriptor de directorio cuando ya no se necesita.</p>
	<p><strong>Prototipo:</strong> La función <strong>closedir()</strong> cierra un directorio abierto previamente con <strong>opendir()</strong>.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">closedir</span>(<span class="types">DIR</span> *<span class="names">dirp</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>dirp</strong>: Puntero al directorio que se va a cerrar.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="keyword">if</span> (<span class="functions">closedir</span>(<span class="names">dir</span>) == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al cerrar el directorio"</span>);
	}
	</code>
	</pre>
	
	<h2>chdir()</h2>
	<p><strong>Función:</strong> Cambia el directorio de trabajo actual del proceso.</p>
	<p><strong>Uso:</strong> Se usa para cambiar el directorio de trabajo de un proceso en ejecución.</p>
	<p><strong>Prototipo:</strong> La función <strong>chdir()</strong> cambia el directorio de trabajo actual del proceso a la ruta especificada.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">chdir</span>(<span class="types">const char</span> <span class="names">*path</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>path</strong>: Ruta al nuevo directorio de trabajo.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">chdir</span>(<span class="data">"/home/user/Documents"</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al cambiar el directorio"</span>);
	}
	</code>
	</pre>


	<h2>dup()</h2>
	<p><strong>Función:</strong> Duplica un descriptor de archivo.</p>
	<p><strong>Uso:</strong> Se utiliza para crear una copia de un descriptor de archivo, permitiendo que ambos descriptores se refieran al mismo archivo o recurso.</p>
	<p><strong>Prototipo:</strong> La función <strong>dup()</strong> duplica un descriptor de archivo y devuelve un nuevo descriptor que apunta al mismo archivo o recurso.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">dup</span>(<span class="types">int</span> <span class="names">oldfd</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>oldfd</strong>: Descriptor de archivo existente que se va a duplicar.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un nuevo descriptor de archivo si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">newfd</span> = <span class="functions">dup</span>(<span class="data">1</span>);  <span class="comment">// Duplica el descriptor de archivo estándar de salida</span>
	<span class="keyword">if</span> (<span class="names">newfd</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al duplicar el descriptor"</span>);
	}
	</code>
	</pre>
	
	<h2>dup2()</h2>
	<p><strong>Función:</strong> Duplica un descriptor de archivo y lo asigna a un descriptor específico.</p>
	<p><strong>Uso:</strong> Similar a <strong>dup()</strong>, pero permite especificar el descriptor de archivo de destino.</p>
	<p><strong>Prototipo:</strong> La función <strong>dup2()</strong> duplica un descriptor de archivo y lo asigna a un descriptor específico.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">dup2</span>(<span class="types">int</span> <span class="names">oldfd</span>, <span class="types">int</span> <span class="names">newfd</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>oldfd</strong>: Descriptor de archivo existente que se va a duplicar.</li>
		<li><strong>newfd</strong>: Nuevo descriptor de archivo al que se asignará el duplicado.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el nuevo descriptor de archivo si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">dup2</span>(<span class="data">0</span>, <span class="data">2</span>);  <span class="comment">// Duplica el descriptor de archivo estándar de entrada al estándar de error</span>
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al duplicar el descriptor"</span>);
	}
	</code>
	</pre>
	
	<h2>pipe()</h2>
	<p><strong>Función:</strong> Crea un canal de comunicación entre procesos mediante descriptores de archivo.</p>
	<p><strong>Uso:</strong> Se utiliza para crear una comunicación unidireccional entre procesos, permitiendo que un proceso escriba y otro lea.</p>
	<p><strong>Prototipo:</strong> La función <strong>pipe()</strong> crea un canal de comunicación que consta de dos descriptores de archivo, uno para leer y otro para escribir.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">pipe</span>(<span class="types">int</span> <span class="names">pipefd[2]</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>pipefd</strong>: Array de dos enteros que se usarán para los descriptores de archivo, uno para lectura y otro para escritura.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">pipefd[2]</span>;
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">pipe</span>(<span class="names">pipefd</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"Error al crear el pipe"</span>);
	}
	</code>
	</pre>
	
	<label for="toogleProcs">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION SOCKETS-->

	<label for="toogleSockets">SOCKETS</label>
	<pre><code class="functionList">socket, accept, listen, send, recv, bind, connect, setsockopt, getsockname, socketpair</code></pre>
	<input type="checkbox" id="toogleSockets" style="display: none;" >
	<section id="sectionSockets">

	<h2>socket()</h2>
	<p><strong>Función:</strong> Crea un nuevo socket para la comunicación en red.</p>
	<p><strong>Uso:</strong> Es el punto de partida para establecer una conexión de red.</p>
	<p><strong>Prototipo:</strong> La función <strong>socket()</strong> crea un nuevo socket que puede ser usado para comunicación entre procesos a través de la red.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">socket</span>(<span class="types">int</span> <span class="names">domain</span>, <span class="types">int</span> <span class="names">type</span>, <span class="types">int</span> <span class="names">protocol</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>domain</strong>: El dominio de la comunicación, como <span class="data">AF_INET</span> para IPv4.</li>
		<li><strong>type</strong>: El tipo de socket, como <span class="data">SOCK_STREAM</span> para TCP.</li>
		<li><strong>protocol</strong>: El protocolo, generalmente se pasa como <span class="data">0</span> para que el sistema seleccione el adecuado según el tipo de socket.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un descriptor de archivo para el socket creado si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">server_fd</span> = <span class="functions">socket</span>(<span class="types">AF_INET</span>, <span class="types">SOCK_STREAM</span>, <span class="data">0</span>);
	<span class="keyword">if</span> (<span class="names">server_fd</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"socket failed"</span>);
	}
	</code>
	</pre>
	
	<h2>accept()</h2>
	<p><strong>Función:</strong> Acepta una conexión entrante en un socket de escucha.</p>
	<p><strong>Uso:</strong> Se utiliza en el lado del servidor para aceptar las conexiones de los clientes.</p>
	<p><strong>Prototipo:</strong> La función <strong>accept()</strong> acepta una solicitud de conexión entrante en el socket de escucha.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">accept</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">struct sockaddr</span> <span class="names">*addr</span>, <span class="types">socklen_t</span> <span class="names">*addrlen</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket de escucha.</li>
		<li><strong>addr</strong>: Estructura donde se guardará la información de la conexión entrante.</li>
		<li><strong>addrlen</strong>: Tamaño de la estructura <span class="names">addr</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un descriptor de archivo para el socket de la conexión aceptada, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">new_socket</span> = <span class="functions">accept</span>(<span class="names">server_fd</span>, <span class="names">&client_addr</span>, <span class="names">&addr_len</span>);
	<span class="keyword">if</span> (<span class="names">new_socket</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"accept failed"</span>);
	}
	</code>
	</pre>
	
	<h2>listen()</h2>
	<p><strong>Función:</strong> Prepara un socket para aceptar conexiones entrantes.</p>
	<p><strong>Uso:</strong> Se utiliza en el lado del servidor para escuchar las solicitudes de conexión de los clientes.</p>
	<p><strong>Prototipo:</strong> La función <strong>listen()</strong> convierte un socket en un socket de escucha.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">listen</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">int</span> <span class="names">backlog</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket que se va a preparar para escuchar.</li>
		<li><strong>backlog</strong>: El número de conexiones que pueden estar en espera.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">listen</span>(<span class="names">server_fd</span>, <span class="data">10</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"listen failed"</span>);
	}
	</code>
	</pre>
	
	<h2>send()</h2>
	<p><strong>Función:</strong> Envía datos a través de un socket conectado.</p>
	<p><strong>Uso:</strong> Se utiliza para enviar datos desde el cliente al servidor o entre procesos.</p>
	<p><strong>Prototipo:</strong> La función <strong>send()</strong> envía datos a través de un socket conectado.</p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">send</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">const void</span> <span class="names">*buf</span>, <span class="types">size_t</span> <span class="names">len</span>, <span class="types">int</span> <span class="names">flags</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>buf</strong>: El búfer que contiene los datos a enviar.</li>
		<li><strong>len</strong>: La longitud de los datos a enviar.</li>
		<li><strong>flags</strong>: Opciones de envío, generalmente se pasa como <span class="data">0</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de bytes enviados, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">const</span> <span class="types">char</span> <span class="names">message</span>[] = <span class="data">"Hello, Server!"</span>;
	<span class="types">ssize_t</span> <span class="names">bytes_sent</span> = <span class="functions">send</span>(<span class="names">sockfd</span>, <span class="names">message</span>, <span class="data">strlen</span>(<span class="names">message</span>), <span class="data">0</span>);
	<span class="keyword">if</span> (<span class="names">bytes_sent</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"send failed"</span>);
	}
	</code>
	</pre>
	
	<h2>recv()</h2>
	<p><strong>Función:</strong> Recibe datos a través de un socket conectado.</p>
	<p><strong>Uso:</strong> Se utiliza para recibir datos de un socket, generalmente usado en el lado del servidor o en el receptor de datos.</p>
	<p><strong>Prototipo:</strong> La función <strong>recv()</strong> recibe datos de un socket conectado.</p>
	<pre>
	<code>
	<span class="types">ssize_t</span> <span class="names">recv</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">void</span> <span class="names">*buf</span>, <span class="types">size_t</span> <span class="names">len</span>, <span class="types">int</span> <span class="names">flags</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>buf</strong>: El búfer donde se almacenarán los datos recibidos.</li>
		<li><strong>len</strong>: La longitud máxima de los datos a recibir.</li>
		<li><strong>flags</strong>: Opciones de recepción, generalmente se pasa como <span class="data">0</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de bytes recibidos, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">char</span> <span class="names">buffer</span>[<span class="data">1024</span>];
	<span class="types">ssize_t</span> <span class="names">bytes_received</span> = <span class="functions">recv</span>(<span class="names">sockfd</span>, <span class="names">buffer</span>, <span class="data">1024</span>, <span class="data">0</span>);
	<span class="keyword">if</span> (<span class="names">bytes_received</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"recv failed"</span>);
	}
	</code>
	</pre>

	<h2>bind()</h2>
	<p><strong>Función:</strong> Asocia un socket con una dirección local.</p>
	<p><strong>Uso:</strong> Se utiliza para asociar un socket con una dirección específica (como una dirección IP y un puerto) en el servidor.</p>
	<p><strong>Prototipo:</strong> La función <strong>bind()</strong> asocia un socket con una dirección y puerto especificados en el servidor.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">bind</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">const struct sockaddr</span> <span class="names">*addr</span>, <span class="types">socklen_t</span> <span class="names">addrlen</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>addr</strong>: La dirección con la que se desea asociar el socket (estructura de tipo <span class="types">struct sockaddr</span>).</li>
		<li><strong>addrlen</strong>: El tamaño de la estructura <span class="names">addr</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct sockaddr_in</span> <span class="names">server_addr</span>;
	<span class="types">memset</span>(&<span class="names">server_addr</span>, <span class="data">0</span>, <span class="data">sizeof</span>(<span class="names">server_addr</span>));
	<span class="names">server_addr</span>.<span class="names">sin_family</span> = <span class="types">AF_INET</span>;
	<span class="names">server_addr</span>.<span class="names">sin_addr.s_addr</span> = <span class="data">INADDR_ANY</span>;
	<span class="names">server_addr</span>.<span class="names">sin_port</span> = <span class="data">htons</span>(<span class="data">8080</span>);
	
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">bind</span>(<span class="names">server_fd</span>, (<span class="types">struct sockaddr</span> *)&<span class="names">server_addr</span>, <span class="types">sizeof</span>(<span class="names">server_addr</span>));
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"bind failed"</span>);
	}
	</code>
	</pre>
	
	<h2>connect()</h2>
	<p><strong>Función:</strong> Establece una conexión a un socket remoto.</p>
	<p><strong>Uso:</strong> Se utiliza en el lado del cliente para establecer una conexión con el servidor.</p>
	<p><strong>Prototipo:</strong> La función <strong>connect()</strong> establece una conexión entre un socket y una dirección remota.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">connect</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">const struct sockaddr</span> <span class="names">*addr</span>, <span class="types">socklen_t</span> <span class="names">addrlen</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>addr</strong>: La dirección remota del servidor con el que se desea establecer la conexión.</li>
		<li><strong>addrlen</strong>: El tamaño de la estructura <span class="names">addr</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct sockaddr_in</span> <span class="names">server_addr</span>;
	<span class="names">server_addr</span>.<span class="names">sin_family</span> = <span class="types">AF_INET</span>;
	<span class="names">server_addr</span>.<span class="names">sin_port</span> = <span class="data">htons</span>(<span class="data">8080</span>);
	<span class="names">server_addr</span>.<span class="names">sin_addr.s_addr</span> = <span class="data">inet_addr</span>(<span class="data">"127.0.0.1"</span>);
	
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">connect</span>(<span class="names">sockfd</span>, (<span class="types">struct sockaddr</span> *)&<span class="names">server_addr</span>, <span class="types">sizeof</span>(<span class="names">server_addr</span>));
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"connect failed"</span>);
	}
	</code>
	</pre>
	
	<h2>setsockopt()</h2>
	<p><strong>Función:</strong> Establece opciones de socket.</p>
	<p><strong>Uso:</strong> Se utiliza para configurar las opciones de un socket, como los límites de tiempo de espera.</p>
	<p><strong>Prototipo:</strong> La función <strong>setsockopt()</strong> se usa para configurar opciones como el tiempo de espera en un socket.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">setsockopt</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">int</span> <span class="names">level</span>, <span class="types">int</span> <span class="names">optname</span>, <span class="types">const void</span> <span class="names">*optval</span>, <span class="types">socklen_t</span> <span class="names">optlen</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>level</strong>: El nivel de la opción (por ejemplo, <span class="data">SOL_SOCKET</span> para opciones de socket comunes).</li>
		<li><strong>optname</strong>: El nombre de la opción (por ejemplo, <span class="data">SO_REUSEADDR</span> para permitir la reutilización de direcciones).</li>
		<li><strong>optval</strong>: El valor de la opción.</li>
		<li><strong>optlen</strong>: El tamaño de la opción.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">reuse</span> = <span class="data">1</span>;
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">setsockopt</span>(<span class="names">sockfd</span>, <span class="types">SOL_SOCKET</span>, <span class="types">SO_REUSEADDR</span>, &<span class="names">reuse</span>, <span class="types">sizeof</span>(<span class="names">reuse</span>));
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"setsockopt failed"</span>);
	}
	</code>
	</pre>
	
	<h2>getsockname()</h2>
	<p><strong>Función:</strong> Obtiene la dirección local asociada a un socket.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener la dirección y el puerto local asociado a un socket.</p>
	<p><strong>Prototipo:</strong> La función <strong>getsockname()</strong> obtiene la dirección local de un socket conectado o enlazado.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">getsockname</span>(<span class="types">int</span> <span class="names">sockfd</span>, <span class="types">struct sockaddr</span> <span class="names">*addr</span>, <span class="types">socklen_t</span> <span class="names">*addrlen</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>sockfd</strong>: El descriptor de archivo del socket.</li>
		<li><strong>addr</strong>: Estructura donde se almacenará la dirección local.</li>
		<li><strong>addrlen</strong>: El tamaño de la estructura <span class="names">addr</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct sockaddr_in</span> <span class="names">local_addr</span>;
	<span class="types">socklen_t</span> <span class="names">addr_len</span> = <span class="types">sizeof</span>(<span class="names">local_addr</span>);
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">getsockname</span>(<span class="names">sockfd</span>, (<span class="types">struct sockaddr</span> *)&<span class="names">local_addr</span>, &<span class="names">addr_len</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"getsockname failed"</span>);
	}
	</code>
	</pre>
	
	<h2>socketpair()</h2>
	<p><strong>Función:</strong> Crea un par de sockets conectados.</p>
	<p><strong>Uso:</strong> Se utiliza para crear un par de sockets de comunicación entre dos procesos en la misma máquina.</p>
	<p><strong>Prototipo:</strong> La función <strong>socketpair()</strong> crea dos sockets conectados.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">socketpair</span>(<span class="types">int</span> <span class="names">domain</span>, <span class="types">int</span> <span class="names">type</span>, <span class="types">int</span> <span class="names">protocol</span>, <span class="types">int</span> <span class="names">sv[2]</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>domain</strong>: El dominio de la comunicación, como <span class="data">AF_UNIX</span>.</li>
		<li><strong>type</strong>: El tipo de socket, generalmente <span class="data">SOCK_STREAM</span>.</li>
		<li><strong>protocol</strong>: El protocolo, generalmente se pasa como <span class="data">0</span>.</li>
		<li><strong>sv</strong>: Un arreglo que almacenará los descriptores de archivo de los dos sockets.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o <span class="data">-1</span> en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">sv[2]</span>;
	<span class="types">int</span> <span class="names">result</span> = <span class="functions">socketpair</span>(<span class="types">AF_UNIX</span>, <span class="types">SOCK_STREAM</span>, <span class="data">0</span>, <span class="names">sv</span>);
	<span class="keyword">if</span> (<span class="names">result</span> == <span class="data">-1</span>) {
		<span class="functions">perror</span>(<span class="data">"socketpair failed"</span>);
	}
	</code>
	</pre>
	
	<label for="toogleSockets">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION DIRECCIONES DE RED-->

	<label for="toogleAddress">DIRECCIONES DE RED</label>
	<pre><code class="functionList">getaddrinfo, freeaddrinfo, gai_strerror, getprotobyname, htons, htonl, ntohs, ntohl</code></pre>
	<input type="checkbox" id="toogleAddress" style="display: none;" >
	<section id="sectionAddress">

	<h2>getaddrinfo()</h2>
	<p><strong>Función:</strong> Resuelve un nombre de host o una dirección IP en una lista de direcciones.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener direcciones y protocolos de red a partir de un nombre de dominio o dirección IP.</p>
	<p><strong>Prototipo:</strong> La función <strong>getaddrinfo()</strong> obtiene una lista de direcciones de red que coinciden con una solicitud específica, utilizando el sistema de nombres de dominio o una dirección IP.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">getaddrinfo</span>(<span class="types">const char</span> <span class="names">*node</span>, <span class="types">const char</span> <span class="names">*service</span>, <span class="types">const struct addrinfo</span> <span class="names">*hints</span>, <span class="types">struct addrinfo</span> <span class="names">**res</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>node</strong>: El nombre del host o la dirección IP.</li>
		<li><strong>service</strong>: El nombre del servicio o el puerto, como "http" o "8080".</li>
		<li><strong>hints</strong>: Un puntero a una estructura <span class="types">struct addrinfo</span> que especifica las condiciones que deben cumplir los resultados (como el tipo de socket).</li>
		<li><strong>res</strong>: Un puntero a una lista de resultados de tipo <span class="types">struct addrinfo</span> que será llenada con la información obtenida.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve <span class="data">0</span> si tiene éxito, o un valor negativo en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct addrinfo</span> <span class="names">hints</span>, <span class="names">*res</span>;
	<span class="types">memset</span>(&<span class="names">hints</span>, <span class="data">0</span>, <span class="types">sizeof</span>(<span class="names">hints</span>));
	<span class="names">hints</span>.<span class="names">ai_family</span> = <span class="types">AF_INET</span>;  <span class="comment">// IPV4</span>
	<span class="names">hints</span>.<span class="names">ai_socktype</span> = <span class="types">SOCK_STREAM</span>;  <span class="comment">// TCP</span>
	
	<span class="types">int</span> <span class="names">status</span> = <span class="functions">getaddrinfo</span>(<span class="data">"www.example.com"</span>, <span class="data">"80"</span>, &<span class="names">hints</span>, &<span class="names">res</span>);
	<span class="keyword">if</span> (<span class="names">status</span> != <span class="data">0</span>) {
		<span class="functions">fprintf</span>(stderr, <span class="data">"getaddrinfo: %s\n"</span>, <span class="names">gai_strerror</span>(<span class="names">status</span>));
		<span class="keyword">return</span> <span class="data">1</span>;
	}
	</code>
	</pre>
	
	<h2>freeaddrinfo()</h2>
	<p><strong>Función:</strong> Libera la memoria asociada a una lista de direcciones obtenida con <strong>getaddrinfo()</strong>.</p>
	<p><strong>Uso:</strong> Se utiliza para liberar la memoria que fue previamente asignada por <strong>getaddrinfo()</strong>.</p>
	<p><strong>Prototipo:</strong> La función <strong>freeaddrinfo()</strong> libera una lista de direcciones obtenida por <strong>getaddrinfo()</strong>.</p>
	<pre>
	<code>
	<span class="types">void</span> <span class="names">freeaddrinfo</span>(<span class="types">struct addrinfo</span> <span class="names">*res</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>res</strong>: Un puntero a una lista de direcciones (<span class="types">struct addrinfo</span>) que debe ser liberada.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> No tiene valor de retorno.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="functions">freeaddrinfo</span>(<span class="names">res</span>);
	</code>
	</pre>
	
	<h2>gai_strerror()</h2>
	<p><strong>Función:</strong> Convierte un código de error de <strong>getaddrinfo()</strong> a una cadena de caracteres descriptiva.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener un mensaje de error legible a partir del código de error retornado por <strong>getaddrinfo()</strong>.</p>
	<p><strong>Prototipo:</strong> La función <strong>gai_strerror()</strong> devuelve una cadena que describe el error que ocurrió con <strong>getaddrinfo()</strong>.</p>
	<pre>
	<code>
	<span class="types">const char</span> *<span class="names">gai_strerror</span>(<span class="types">int</span> <span class="names">ecode</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>ecode</strong>: El código de error que se desea describir, que puede ser el valor retornado por <strong>getaddrinfo()</strong>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve una cadena de caracteres que describe el error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">status</span> = <span class="functions">getaddrinfo</span>(<span class="data">"nonexistent.domain"</span>, <span class="data">"80"</span>, &<span class="names">hints</span>, &<span class="names">res</span>);
	<span class="keyword">if</span> (<span class="names">status</span> != <span class="data">0</span>) {
		<span class="functions">fprintf</span>(stderr, <span class="data">"getaddrinfo: %s\n"</span>, <span class="names">gai_strerror</span>(<span class="names">status</span>));
	}
	</code>
	</pre>
	
	<h2>getprotobyname()</h2>
	<p><strong>Función:</strong> Obtiene el número de protocolo asociado a un nombre de protocolo.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener información sobre un protocolo a partir de su nombre, como "tcp" o "udp".</p>
	<p><strong>Prototipo:</strong> La función <strong>getprotobyname()</strong> obtiene la estructura de protocolo que corresponde a un nombre de protocolo.</p>
	<pre>
	<code>
	<span class="types">struct protoent</span> *<span class="names">getprotobyname</span>(<span class="types">const char</span> <span class="names">*name</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>name</strong>: El nombre del protocolo, como <span class="data">"tcp"</span> o <span class="data">"udp"</span>.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un puntero a una estructura <span class="types">protoent</span> que contiene información sobre el protocolo, o <span class="data">NULL</span> si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct protoent</span> <span class="names">*proto</span>;
	<span class="names">proto</span> = <span class="functions">getprotobyname</span>(<span class="data">"tcp"</span>);
	<span class="keyword">if</span> (<span class="names">proto</span> == <span class="data">NULL</span>) {
		<span class="functions">perror</span>(<span class="data">"getprotobyname failed"</span>);
	} <span class="keyword">else</span> {
		<span class="functions">printf</span>(<span class="data">"Protocol number for TCP: %d\n"</span>, <span class="names">proto</span>.<span class="names">p_proto</span>);
	}
	</code>
	</pre>
	
	<h2>htons()</h2>
	<p><strong>Función:</strong> Convierte un valor de 16 bits de orden de bytes de host a orden de bytes de red (big-endian).</p>
	<p><strong>Uso:</strong> Se utiliza para convertir un valor de 16 bits a su formato adecuado para su transmisión a través de la red.</p>
	<p><strong>Prototipo:</strong> La función <strong>htons()</strong> convierte un valor de 16 bits desde el orden de bytes del host al orden de bytes de la red.</p>
	<pre>
	<code>
	<span class="types">uint16_t</span> <span class="names">htons</span>(<span class="types">uint16_t</span> <span class="names">hostshort</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>hostshort</strong>: El valor de 16 bits que se desea convertir de formato host a formato de red.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el valor convertido a orden de bytes de red.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">uint16_t</span> <span class="names">port</span> = <span class="data">8080</span>;
	<span class="types">uint16_t</span> <span class="names">network_port</span> = <span class="names">htons</span>(<span class="names">port</span>);
	</code>
	</pre>
	
	<h2>htonl()</h2>
	<p><strong>Función:</strong> Convierte un valor de 32 bits de orden de bytes de host a orden de bytes de red (big-endian).</p>
	<p><strong>Uso:</strong> Se utiliza para convertir un valor de 32 bits a su formato adecuado para su transmisión a través de la red.</p>
	<p><strong>Prototipo:</strong> La función <strong>htonl()</strong> convierte un valor de 32 bits desde el orden de bytes del host al orden de bytes de la red.</p>
	<pre>
	<code>
	<span class="types">uint32_t</span> <span class="names">htonl</span>(<span class="types">uint32_t</span> <span class="names">hostlong</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>hostlong</strong>: El valor de 32 bits que se desea convertir de formato host a formato de red.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el valor convertido a orden de bytes de red.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">uint32_t</span> <span class="names">ip_address</span> = <span class="data">0x7f000001</span>; <span class="comment">// 127.0.0.1 en hexadecimal</span>
	<span class="types">uint32_t</span> <span class="names">network_ip</span> = <span class="names">htonl</span>(<span class="names">ip_address</span>);
	</code>
	</pre>
	
	<h2>ntohs()</h2>
	<p><strong>Función:</strong> Convierte un valor de 16 bits de orden de bytes de red a orden de bytes de host.</p>
	<p><strong>Uso:</strong> Se utiliza para convertir un valor de 16 bits de formato de red a formato host, utilizado cuando se recibe información de la red.</p>
	<p><strong>Prototipo:</strong> La función <strong>ntohs()</strong> convierte un valor de 16 bits desde el orden de bytes de red al orden de bytes del host.</p>
	<pre>
	<code>
	<span class="types">uint16_t</span> <span class="names">ntohs</span>(<span class="types">uint16_t</span> <span class="names">netshort</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>netshort</strong>: El valor de 16 bits que se desea convertir de formato de red a formato host.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el valor convertido a orden de bytes del host.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">uint16_t</span> <span class="names">network_port</span> = <span class="data">0x1F90</span>; <span class="comment">// 8080 en hexadecimal (formato de red)
	<span class="types">uint16_t</span> <span class="names">host_port</span> = <span class="names">ntohs</span>(<span class="names">network_port</span>);
	</code>
	</pre>
	
	<h2>ntohl()</h2>
	<p><strong>Función:</strong> Convierte un valor de 32 bits de orden de bytes de red a orden de bytes de host.</p>
	<p><strong>Uso:</strong> Se utiliza para convertir un valor de 32 bits de formato de red a formato host, utilizado cuando se recibe información de la red.</p>
	<p><strong>Prototipo:</strong> La función <strong>ntohl()</strong> convierte un valor de 32 bits desde el orden de bytes de red al orden de bytes del host.</p>
	<pre>
	<code>
	<span class="types">uint32_t</span> <span class="names">ntohl</span>(<span class="types">uint32_t</span> <span class="names">netlong</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>netlong</strong>: El valor de 32 bits que se desea convertir de formato de red a formato host.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el valor convertido a orden de bytes del host.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">uint32_t</span> <span class="names">network_ip</span> = <span class="data">0x7f000001</span>; <span class="comment">// 127.0.0.1 en formato de red
	<span class="types">uint32_t</span> <span class="names">host_ip</span> = <span class="names">ntohl</span>(<span class="names">network_ip</span>);
	</code>
	</pre>
	
	<label for="toogleAddress">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION EVENTOS DE SISTEMA-->

	<label for="toogleEvents">EVENTOS DE SISTEMA</label>
	<pre><code class="functionList">select, poll, epoll, epoll_create, epoll_ctl, epoll_wait, kqueue, kevent</code></pre>
	<input type="checkbox" id="toogleEvents" style="display: none;" >
	<section id="sectionEvents">

	<h2>select()</h2>
	<p><strong>Función:</strong> Permite la supervisión de múltiples descriptores de archivo para ver si alguno de ellos está listo para la lectura, escritura o si ha ocurrido una excepción.</p>
	<p><strong>Uso:</strong> Se utiliza para gestionar la entrada/salida no bloqueante en múltiples descriptores de archivo, como sockets y archivos.</p>
	<p><strong>Prototipo:</strong> La función <strong>select()</strong> permite esperar hasta que uno o más descriptores de archivo sean accesibles para la lectura, escritura o si ha ocurrido alguna excepción.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">select</span>(<span class="types">int</span> <span class="names">nfds</span>, 
					<span class="types">fd_set *</span> <span class="names">readfds</span>, 
					<span class="types">fd_set *</span> <span class="names">writefds</span>, 
					<span class="types">fd_set *</span> <span class="names">exceptfds</span>, 
					<span class="types">struct timeval *</span> <span class="names">timeout</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>nfds</strong>: El valor más alto de descriptor de archivo más 1.</li>
		<li><strong>readfds</strong>: Conjunto de descriptores de archivo a verificar para lectura.</li>
		<li><strong>writefds</strong>: Conjunto de descriptores de archivo a verificar para escritura.</li>
		<li><strong>exceptfds</strong>: Conjunto de descriptores de archivo a verificar para excepciones.</li>
		<li><strong>timeout</strong>: Estructura de tiempo que especifica el máximo tiempo de espera.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de descriptores de archivo listos, o -1 si hay error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">fd_set</span> <span class="names">readfds</span>;
	<span class="types">struct timeval</span> <span class="names">timeout</span>;
	<span class="names">FD_ZERO</span>(&<span class="names">readfds</span>);
	<span class="names">FD_SET</span>(<span class="data">0</span>, &<span class="names">readfds</span>); <span class="comment">// 0 es stdin</span>
	<span class="names">timeout</span>.<span class="names">tv_sec</span> = <span class="data">5</span>;
	<span class="names">timeout</span>.<span class="names">tv_usec</span> = <span class="data">0</span>;
	
	<span class="types">int</span> <span class="names">ret</span> = <span class="names">select</span>(<span class="data">1</span>, &<span class="names">readfds</span>, <span class="names">NULL</span>, <span class="names">NULL</span>, &<span class="names">timeout</span>);
	<span class="keyword">if</span> (<span class="names">ret</span> == <span class="data">0</span>) {
		<span class="names">printf</span>(<span class="data">"Tiempo agotado"</span>);
	} <span class="keyword">else</span> {
		<span class="names">printf</span>(<span class="data">"Datos disponibles para leer"</span>);
	}
	</code>
	</pre>
	
	<h2>poll()</h2>
	<p><strong>Función:</strong> Similar a <strong>select()</strong>, se utiliza para esperar eventos en múltiples descriptores de archivo, pero usa una estructura diferente.</p>
	<p><strong>Uso:</strong> Se utiliza para gestionar la entrada/salida en múltiples descriptores de archivo de manera más eficiente que <strong>select()</strong> en algunas circunstancias.</p>
	<p><strong>Prototipo:</strong> La función <strong>poll()</strong> permite esperar hasta que uno o más descriptores de archivo estén listos para realizar operaciones de lectura, escritura o excepciones.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">poll</span>(<span class="types">struct pollfd *</span> <span class="names">fds</span>, 
					<span class="types">nfds_t</span> <span class="names">nfds</span>, 
					<span class="types">int</span> <span class="names">timeout</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>fds</strong>: Arreglo de estructuras <strong>pollfd</strong>, cada una de las cuales describe un descriptor de archivo.</li>
		<li><strong>nfds</strong>: Número de descriptores de archivo a verificar.</li>
		<li><strong>timeout</strong>: El tiempo de espera en milisegundos.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de descriptores de archivo que están listos, 0 si hay un timeout, o -1 en caso de error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct pollfd</span> <span class="names">fds</span>[<span class="data">1</span>];
	<span class="names">fds</span>[<span class="data">0</span>].<span class="names">fd</span> = <span class="data">0</span>; <span class="comment">// stdin</span>
	<span class="names">fds</span>[<span class="data">0</span>].<span class="names">events</span> = <span class="data">POLLIN</span>;
	
	<span class="types">int</span> <span class="names">ret</span> = <span class="names">poll</span>(&<span class="names">fds</span>, <span class="data">1</span>, <span class="data">5000</span>);
	<span class="keyword">if</span> (<span class="names">ret</span> == <span class="data">0</span>) {
		<span class="names">printf</span>(<span class="data">"Tiempo agotado"</span>);
	} <span class="keyword">else if</span> (<span class="names">fds</span>[<span class="data">0</span>].<span class="names">revents</span> & <span class="data">POLLIN</span>) {
		<span class="names">printf</span>(<span class="data">"Datos disponibles para leer"</span>);
	}
	</code>
	</pre>

	<h2>epoll_create()</h2>
	<p><strong>Función:</strong> Crea una instancia de epoll, un mecanismo eficiente para monitorear múltiples descriptores de archivo en sistemas Linux.</p>
	<p><strong>Uso:</strong> Se utiliza para crear un archivo especial que se utiliza para realizar un seguimiento de los eventos en varios descriptores de archivo, mejorando la eficiencia respecto a `select()` y `poll()`.</p>
	<p><strong>Prototipo:</strong> La función <strong>epoll_create()</strong> crea un objeto epoll que será utilizado posteriormente para monitorear eventos en múltiples descriptores de archivo.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">epoll_create</span>(<span class="types">int</span> <span class="names">size</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>size</strong>: Aproximación del número máximo de descriptores que se monitorearán. Aunque el tamaño no es limitante, es una sugerencia para la implementación.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un descriptor de archivo para el nuevo objeto epoll, o -1 si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">epoll_fd</span> = <span class="names">epoll_create</span>(<span class="data">10</span>);
	<span class="keyword">if</span> (<span class="names">epoll_fd</span> == <span class="data">-1</span>) {
		<span class="names">perror</span>(<span class="data">"epoll_create error"</span>);
	}
	</code>
	</pre>
	
	<h2>epoll_ctl()</h2>
	<p><strong>Función:</strong> Controla la instancia de epoll para agregar, eliminar o modificar descriptores de archivo que se monitorean.</p>
	<p><strong>Uso:</strong> Se utiliza para modificar los descriptores de archivo registrados en un objeto epoll, especificando qué eventos deben ser monitoreados para cada descriptor.</p>
	<p><strong>Prototipo:</strong> La función <strong>epoll_ctl()</strong> se usa para registrar, eliminar o modificar los descriptores de archivo que deben ser monitoreados.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">epoll_ctl</span>(<span class="types">int</span> <span class="names">epoll_fd</span>, 
					<span class="types">int</span> <span class="names">op</span>, 
					<span class="types">int</span> <span class="names">fd</span>, 
					<span class="types">struct epoll_event *</span> <span class="names">event</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>epoll_fd</strong>: Descriptor del objeto epoll.</li>
		<li><strong>op</strong>: Operación a realizar: <strong>EPOLL_CTL_ADD</strong>, <strong>EPOLL_CTL_MOD</strong>, o <strong>EPOLL_CTL_DEL</strong>.</li>
		<li><strong>fd</strong>: Descriptor del archivo a modificar.</li>
		<li><strong>event</strong>: Estructura que especifica los eventos que se deben monitorear para el descriptor.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve 0 en caso de éxito, o -1 si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct epoll_event</span> <span class="names">event</span>;
	<span class="names">event</span>.<span class="names">events</span> = <span class="data">EPOLLIN</span>;
	<span class="names">event</span>.<span class="names">data</span>.<span class="names">fd</span> = <span class="data">stdin</span>;
	
	<span class="types">int</span> <span class="names">ret</span> = <span class="names">epoll_ctl</span>(<span class="names">epoll_fd</span>, <span class="data">EPOLL_CTL_ADD</span>, <span class="data">0</span>, &<span class="names">event</span>);
	<span class="keyword">if</span> (<span class="names">ret</span> == <span class="data">-1</span>) {
		<span class="names">perror</span>(<span class="data">"epoll_ctl error"</span>);
	}
	</code>
	</pre>
	
	<h2>epoll_wait()</h2>
	<p><strong>Función:</strong> Bloquea el programa y espera eventos en los descriptores de archivo registrados en un objeto epoll.</p>
	<p><strong>Uso:</strong> Se utiliza para esperar los eventos que han ocurrido en los descriptores de archivo monitoreados por un objeto epoll.</p>
	<p><strong>Prototipo:</strong> La función <strong>epoll_wait()</strong> espera eventos en los descriptores registrados y los devuelve cuando están disponibles.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">epoll_wait</span>(<span class="types">int</span> <span class="names">epoll_fd</span>, 
					<span class="types">struct epoll_event *</span> <span class="names">events</span>, 
					<span class="types">int</span> <span class="names">maxevents</span>, 
					<span class="types">int</span> <span class="names">timeout</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>epoll_fd</strong>: Descriptor del objeto epoll.</li>
		<li><strong>events</strong>: Arreglo de estructuras <strong>epoll_event</strong> para recibir los eventos.</li>
		<li><strong>maxevents</strong>: Número máximo de eventos que se pueden devolver.</li>
		<li><strong>timeout</strong>: Tiempo de espera en milisegundos (0 para no bloquear, -1 para esperar indefinidamente).</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de eventos ocurridos, 0 si ha ocurrido un timeout, o -1 si hay un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct epoll_event</span> <span class="names">events</span>[<span class="data">10</span>];
	<span class="types">int</span> <span class="names">num_events</span> = <span class="names">epoll_wait</span>(<span class="names">epoll_fd</span>, <span class="names">events</span>, 
													  <span class="data">10</span>, <span class="data">-1</span>);
	
	<span class="keyword">for</span> (<span class="types">int</span> <span class="names">i</span> = <span class="data">0</span>; <span class="names">i</span> < <span class="names">num_events</span>; <span class="names">i</span>++) {
		<span class="keyword">if</span> (events[i].<span class="names">events</span> & <span class="data">EPOLLIN</span>) {
			<span class="names">printf</span>(<span class="data">"Evento de lectura disponible"</span>);
		}
	}
	</code>
	</pre>
	
	<h2>kqueue()</h2>
	<p><strong>Función:</strong> Crea una instancia de un kqueue, un mecanismo de notificación de eventos utilizado en sistemas BSD.</p>
	<p><strong>Uso:</strong> Se utiliza para crear un objeto kqueue que puede ser utilizado para monitorear eventos en descriptores de archivo, señales y otras notificaciones.</p>
	<p><strong>Prototipo:</strong> La función <strong>kqueue()</strong> se usa para crear un descriptor de archivo especial que puede ser utilizado para gestionar eventos en un sistema.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">kqueue</span>(<span class="types">void</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li>Esta función no toma parámetros. Devuelve un descriptor de archivo que se utiliza para gestionar eventos en un sistema.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un descriptor de archivo para el objeto kqueue, o -1 si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">kq</span> = <span class="names">kqueue</span>();
	<span class="keyword">if</span> (<span class="names">kq</span> == <span class="data">-1</span>) {
		<span class="names">perror</span>(<span class="data">"kqueue error"</span>);
	}
	</code>
	</pre>
	
	<h2>kevent()</h2>
	<p><strong>Función:</strong> Modifica o espera eventos de un objeto kqueue, que puede ser utilizado para monitorear cambios en descriptores de archivo, señales, y otros eventos del sistema.</p>
	<p><strong>Uso:</strong> Se utiliza para añadir, eliminar o modificar eventos en un kqueue, o para bloquear y esperar eventos.</p>
	<p><strong>Prototipo:</strong> La función <strong>kevent()</strong> se usa para modificar un conjunto de eventos o esperar eventos en el kqueue.</p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">kevent</span>(<span class="types">int</span> <span class="names">kq</span>, 
					<span class="types">const struct kevent *</span> <span class="names">changelist</span>, 
					<span class="types">int</span> <span class="names">nchanges</span>, 
					<span class="types">struct kevent *</span> <span class="names">eventlist</span>, 
					<span class="types">int</span> <span class="names">nevents</span>, 
					<span class="types">const struct timespec *</span> <span class="names">timeout</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>kq</strong>: Descriptor del objeto kqueue.</li>
		<li><strong>changelist</strong>: Lista de eventos que se deben agregar o modificar en el kqueue.</li>
		<li><strong>nchanges</strong>: Número de eventos en la lista changelist.</li>
		<li><strong>eventlist</strong>: Lista donde se almacenan los eventos que ocurren.</li>
		<li><strong>nevents</strong>: Número máximo de eventos que se pueden almacenar en eventlist.</li>
		<li><strong>timeout</strong>: Tiempo de espera para bloquear la función. Si es NULL, se bloquea indefinidamente.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve el número de eventos que se han activado, o -1 si ocurre un error.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">struct kevent</span> <span class="names">kev</span>;
	<span class="names">EV_SET</span>(&<span class="names">kev</span>, <span class="data">0</span>, <span class="data">EVFILT_READ</span>, <span class="data">EV_ADD</span>, <span class="data">0</span>, <span class="data">0</span>, <span class="data">NULL</span>);
	
	<span class="types">int</span> <span class="names">ret</span> = <span class="names">kevent</span>(<span class="names">kq</span>, &<span class="names">kev</span>, <span class="data">1</span>, &<span class="names">kev</span>, <span class="data">1</span>, <span class="data">NULL</span>);
	
	<span class="keyword">if</span> (<span class="names">ret</span> == <span class="data">-1</span>) {
		<span class="names">perror</span>(<span class="data">"kevent error"</span>);
	}
	</code>
	</pre>
	
	<label for="toogleEvents">COLAPSAR</label>
	</section>
	<hr>

	<!-- SECCION ERRORES DE SISTEMA-->

	<label for="toogleErrors">ERRORES DE SISTEMA</label>
	<pre><code class="functionList">strerror, errno</code></pre>
	<input type="checkbox" id="toogleErrors" style="display: none;" >
	<section id="sectionErrors">

	<h2>strerror()</h2>
	<p><strong>Función:</strong> Devuelve una cadena de texto que describe un código de error.</p>
	<p><strong>Uso:</strong> Se utiliza para obtener una descripción legible para humanos de los errores que produce una función del sistema o una llamada de biblioteca.</p>
	<p><strong>Prototipo:</strong> La función <strong>strerror()</strong> toma un código de error y devuelve un mensaje descriptivo.</p>
	<pre>
	<code>
	<span class="types">char *</span> <span class="names">strerror</span>(<span class="types">int</span> <span class="names">errnum</span>);
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>errnum</strong>: El código de error que se quiere traducir a texto.</li>
	</ul>
	<p><strong>Valor de retorno:</strong> Devuelve un puntero a una cadena que contiene el mensaje de error correspondiente al código <strong>errnum</strong>.</p>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">fd</span> = <span class="names">open</span>(<span class="data">"/nonexistent"</span>, <span class="data">O_RDONLY</span>);
	<span class="keyword">if</span> (<span class="names">fd</span> == <span class="data">-1</span>) {
		<span class="names">printf</span>(<span class="data">"Error: %s\n"</span>, <span class="names">strerror</span>(<span class="names">errno</span>));
	}
	</code>
	</pre>
	
	<h2>errno</h2>
	<p><strong>Variable:</strong> Es una variable global que contiene el código del último error producido por una función del sistema o llamada de biblioteca.</p>
	<p><strong>Uso:</strong> Se utiliza para diagnosticar errores después de una llamada al sistema o función que falla, proporcionando el código de error correspondiente.</p>
	<p><strong>Definición:</strong> La variable <strong>errno</strong> es declarada en el encabezado <code>&lt;errno.h&gt;</code>.</p>
	<pre>
	<code>
	<span class="keyword">extern</span> <span class="types">int</span> <span class="names">errno</span>;
	</code>
	</pre>
	<p><strong>Explicación:</strong></p>
	<ul>
		<li><strong>errno</strong>: Contiene el código del último error producido. Su valor es sobrescrito por las funciones del sistema al ocurrir un error.</li>
	</ul>
	<p><strong>Notas:</strong></p>
	<ul>
		<li>Antes de invocar cualquier función que pueda modificar <strong>errno</strong>, asegúrate de reiniciarlo si necesitas distinguir entre múltiples errores consecutivos.</li>
	</ul>
	<p><strong>Ejemplo:</strong></p>
	<pre>
	<code>
	<span class="types">int</span> <span class="names">fd</span> = <span class="names">open</span>(<span class="data">"/nonexistent"</span>, <span class="data">O_RDONLY</span>);
	<span class="keyword">if</span> (<span class="names">fd</span> == <span class="data">-1</span>) {
		<span class="names">printf</span>(<span class="data">"Error code: %d\n"</span>, <span class="names">errno</span>);
	}
	</code>
	</pre>
	
	<label for="toogleErrors">COLAPSAR</label>
	</section>
	<hr>

	<label for="toogleFuncs">COLAPSAR</label>
	</section>
	<hr>

